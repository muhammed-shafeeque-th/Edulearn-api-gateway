// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.33.2
// source: user/types/user_types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Error, PaginationRequest, PaginationResponse, SortOption } from "../common";

export const protobufPackage = "user_service";

export enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0,
  ACTIVE = 1,
  BLOCKED = 2,
  DELETED = 3,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "USER_STATUS_UNSPECIFIED":
      return UserStatus.USER_STATUS_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return UserStatus.ACTIVE;
    case 2:
    case "BLOCKED":
      return UserStatus.BLOCKED;
    case 3:
    case "DELETED":
      return UserStatus.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.USER_STATUS_UNSPECIFIED:
      return "USER_STATUS_UNSPECIFIED";
    case UserStatus.ACTIVE:
      return "ACTIVE";
    case UserStatus.BLOCKED:
      return "BLOCKED";
    case UserStatus.DELETED:
      return "DELETED";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UserFilter {
  status: UserStatus;
  email?: string | undefined;
  role?: string | undefined;
  search?: string | undefined;
}

export interface UserProfileData {
  bio: string;
  phone: string;
  country: string;
  city: string;
  gender: string;
  preference: string;
  language: string;
  website: string;
}

export interface UserSocialsData {
  provider: string;
  profileUrl: string;
  providerUserUrl: string;
}

export interface InstructorProfileData {
  bio: string;
  headline: string;
  experience: string;
  certificate: string;
  expertise: string;
  rating: number;
  tags: string[];
  totalRatings: number;
  totalCourses: number;
  totalStudents: number;
  joinedAt: string;
}

export interface UserData {
  id: string;
  email: string;
  role: string;
  firstName: string;
  status: string;
  lastName: string;
  username: string;
  slug: string;
  avatar: string;
  lastLogin: string;
  profile: UserProfileData | undefined;
  instructorProfile: InstructorProfileData | undefined;
  socials: UserSocialsData[];
  updatedAt: string;
  createdAt: string;
}

export interface GetUsersRequest {
  pagination: PaginationRequest | undefined;
  filter: UserFilter | undefined;
  sort: SortOption | undefined;
}

export interface GetUserRequest {
  userId: string;
}

export interface GetUsersByIdsRequest {
  userIds: string[];
}

export interface GetInstructorByNameRequest {
  username: string;
}

export interface GetUserEmailsRequest {
}

export interface CheckUserByEmailRequest {
  email: string;
}

export interface GetCurrentUserRequest {
  userId: string;
}

export interface BlockUserRequest {
  userId: string;
}

export interface UnBlockUserRequest {
  userId: string;
}

export interface UpdateUserDetailsRequest {
  userId: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  socials: UserSocialsData[];
  biography?: string | undefined;
  avatar?: string | undefined;
  website?: string | undefined;
  language?: string | undefined;
  city?: string | undefined;
  country?: string | undefined;
  gender?: string | undefined;
}

export interface ChangePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
}

export interface RegisterInstructorRequest {
  userId: string;
  username: string;
  tags: string[];
  expertise: string;
  experience: string;
  education: string;
  language: string;
  headline: string;
  biography: string;
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
  receiveUpdates: boolean;
}

export interface UserEmailsSuccess {
  email: string[];
}

export interface EmailExist {
  success: string;
  error: string;
}

export interface UsersSuccess {
  users: UserData[];
  pagination: PaginationResponse | undefined;
}

export interface UsersResponse {
  users: UserData[];
}

export interface GetUsersResponse {
  success?: UsersSuccess | undefined;
  error?: Error | undefined;
}

export interface GetUserEmailsResponse {
  success?: UserEmailsSuccess | undefined;
  error?: Error | undefined;
}

export interface GetUsersByIdsResponse {
  success?: UsersResponse | undefined;
  error?: Error | undefined;
}

export interface GetUserResponse {
  user?: UserData | undefined;
  error?: Error | undefined;
}

export interface GetInstructorByNameResponse {
  user?: UserData | undefined;
  error?: Error | undefined;
}

export interface GetCurrentUserResponse {
  user?: UserData | undefined;
  error?: Error | undefined;
}

export interface CheckUserByEmailResponse {
  response?: EmailExist | undefined;
  error?: Error | undefined;
}

export interface BlockUserResponse {
  success?: BlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface UnBlockUserResponse {
  success?: UnBlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface BlockUserSuccess {
  updated: boolean;
}

export interface UnBlockUserSuccess {
  updated: boolean;
}

export interface UpdateUserDetailsResponse {
  user?: UserData | undefined;
  error?: Error | undefined;
}

export interface ChangePasswordResponse {
  success?: ChangePasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ChangePasswordSuccess {
  updated: boolean;
}

function createBaseUserFilter(): UserFilter {
  return { status: 0, email: undefined, role: undefined, search: undefined };
}

export const UserFilter: MessageFns<UserFilter> = {
  encode(message: UserFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.email !== undefined) {
      writer.uint32(18).string(message.email);
    }
    if (message.role !== undefined) {
      writer.uint32(26).string(message.role);
    }
    if (message.search !== undefined) {
      writer.uint32(34).string(message.search);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.search = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserFilter {
    return {
      status: isSet(object.status) ? userStatusFromJSON(object.status) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      role: isSet(object.role) ? globalThis.String(object.role) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
    };
  },

  toJSON(message: UserFilter): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = userStatusToJSON(message.status);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.role !== undefined) {
      obj.role = message.role;
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserFilter>, I>>(base?: I): UserFilter {
    return UserFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserFilter>, I>>(object: I): UserFilter {
    const message = createBaseUserFilter();
    message.status = object.status ?? 0;
    message.email = object.email ?? undefined;
    message.role = object.role ?? undefined;
    message.search = object.search ?? undefined;
    return message;
  },
};

function createBaseUserProfileData(): UserProfileData {
  return { bio: "", phone: "", country: "", city: "", gender: "", preference: "", language: "", website: "" };
}

export const UserProfileData: MessageFns<UserProfileData> = {
  encode(message: UserProfileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bio !== "") {
      writer.uint32(10).string(message.bio);
    }
    if (message.phone !== "") {
      writer.uint32(18).string(message.phone);
    }
    if (message.country !== "") {
      writer.uint32(26).string(message.country);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.gender !== "") {
      writer.uint32(42).string(message.gender);
    }
    if (message.preference !== "") {
      writer.uint32(50).string(message.preference);
    }
    if (message.language !== "") {
      writer.uint32(58).string(message.language);
    }
    if (message.website !== "") {
      writer.uint32(66).string(message.website);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preference = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.website = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileData {
    return {
      bio: isSet(object.bio) ? globalThis.String(object.bio) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      preference: isSet(object.preference) ? globalThis.String(object.preference) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
    };
  },

  toJSON(message: UserProfileData): unknown {
    const obj: any = {};
    if (message.bio !== "") {
      obj.bio = message.bio;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.preference !== "") {
      obj.preference = message.preference;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileData>, I>>(base?: I): UserProfileData {
    return UserProfileData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileData>, I>>(object: I): UserProfileData {
    const message = createBaseUserProfileData();
    message.bio = object.bio ?? "";
    message.phone = object.phone ?? "";
    message.country = object.country ?? "";
    message.city = object.city ?? "";
    message.gender = object.gender ?? "";
    message.preference = object.preference ?? "";
    message.language = object.language ?? "";
    message.website = object.website ?? "";
    return message;
  },
};

function createBaseUserSocialsData(): UserSocialsData {
  return { provider: "", profileUrl: "", providerUserUrl: "" };
}

export const UserSocialsData: MessageFns<UserSocialsData> = {
  encode(message: UserSocialsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.profileUrl !== "") {
      writer.uint32(18).string(message.profileUrl);
    }
    if (message.providerUserUrl !== "") {
      writer.uint32(26).string(message.providerUserUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSocialsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSocialsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profileUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerUserUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSocialsData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      profileUrl: isSet(object.profileUrl) ? globalThis.String(object.profileUrl) : "",
      providerUserUrl: isSet(object.providerUserUrl) ? globalThis.String(object.providerUserUrl) : "",
    };
  },

  toJSON(message: UserSocialsData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.profileUrl !== "") {
      obj.profileUrl = message.profileUrl;
    }
    if (message.providerUserUrl !== "") {
      obj.providerUserUrl = message.providerUserUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserSocialsData>, I>>(base?: I): UserSocialsData {
    return UserSocialsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserSocialsData>, I>>(object: I): UserSocialsData {
    const message = createBaseUserSocialsData();
    message.provider = object.provider ?? "";
    message.profileUrl = object.profileUrl ?? "";
    message.providerUserUrl = object.providerUserUrl ?? "";
    return message;
  },
};

function createBaseInstructorProfileData(): InstructorProfileData {
  return {
    bio: "",
    headline: "",
    experience: "",
    certificate: "",
    expertise: "",
    rating: 0,
    tags: [],
    totalRatings: 0,
    totalCourses: 0,
    totalStudents: 0,
    joinedAt: "",
  };
}

export const InstructorProfileData: MessageFns<InstructorProfileData> = {
  encode(message: InstructorProfileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bio !== "") {
      writer.uint32(10).string(message.bio);
    }
    if (message.headline !== "") {
      writer.uint32(18).string(message.headline);
    }
    if (message.experience !== "") {
      writer.uint32(26).string(message.experience);
    }
    if (message.certificate !== "") {
      writer.uint32(34).string(message.certificate);
    }
    if (message.expertise !== "") {
      writer.uint32(42).string(message.expertise);
    }
    if (message.rating !== 0) {
      writer.uint32(48).int32(message.rating);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.totalRatings !== 0) {
      writer.uint32(64).int32(message.totalRatings);
    }
    if (message.totalCourses !== 0) {
      writer.uint32(72).int32(message.totalCourses);
    }
    if (message.totalStudents !== 0) {
      writer.uint32(80).int32(message.totalStudents);
    }
    if (message.joinedAt !== "") {
      writer.uint32(90).string(message.joinedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstructorProfileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructorProfileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headline = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.experience = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.certificate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expertise = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rating = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalRatings = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.totalCourses = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.totalStudents = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.joinedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructorProfileData {
    return {
      bio: isSet(object.bio) ? globalThis.String(object.bio) : "",
      headline: isSet(object.headline) ? globalThis.String(object.headline) : "",
      experience: isSet(object.experience) ? globalThis.String(object.experience) : "",
      certificate: isSet(object.certificate) ? globalThis.String(object.certificate) : "",
      expertise: isSet(object.expertise) ? globalThis.String(object.expertise) : "",
      rating: isSet(object.rating) ? globalThis.Number(object.rating) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      totalRatings: isSet(object.totalRatings) ? globalThis.Number(object.totalRatings) : 0,
      totalCourses: isSet(object.totalCourses) ? globalThis.Number(object.totalCourses) : 0,
      totalStudents: isSet(object.totalStudents) ? globalThis.Number(object.totalStudents) : 0,
      joinedAt: isSet(object.joinedAt) ? globalThis.String(object.joinedAt) : "",
    };
  },

  toJSON(message: InstructorProfileData): unknown {
    const obj: any = {};
    if (message.bio !== "") {
      obj.bio = message.bio;
    }
    if (message.headline !== "") {
      obj.headline = message.headline;
    }
    if (message.experience !== "") {
      obj.experience = message.experience;
    }
    if (message.certificate !== "") {
      obj.certificate = message.certificate;
    }
    if (message.expertise !== "") {
      obj.expertise = message.expertise;
    }
    if (message.rating !== 0) {
      obj.rating = Math.round(message.rating);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.totalRatings !== 0) {
      obj.totalRatings = Math.round(message.totalRatings);
    }
    if (message.totalCourses !== 0) {
      obj.totalCourses = Math.round(message.totalCourses);
    }
    if (message.totalStudents !== 0) {
      obj.totalStudents = Math.round(message.totalStudents);
    }
    if (message.joinedAt !== "") {
      obj.joinedAt = message.joinedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstructorProfileData>, I>>(base?: I): InstructorProfileData {
    return InstructorProfileData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstructorProfileData>, I>>(object: I): InstructorProfileData {
    const message = createBaseInstructorProfileData();
    message.bio = object.bio ?? "";
    message.headline = object.headline ?? "";
    message.experience = object.experience ?? "";
    message.certificate = object.certificate ?? "";
    message.expertise = object.expertise ?? "";
    message.rating = object.rating ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.totalRatings = object.totalRatings ?? 0;
    message.totalCourses = object.totalCourses ?? 0;
    message.totalStudents = object.totalStudents ?? 0;
    message.joinedAt = object.joinedAt ?? "";
    return message;
  },
};

function createBaseUserData(): UserData {
  return {
    id: "",
    email: "",
    role: "",
    firstName: "",
    status: "",
    lastName: "",
    username: "",
    slug: "",
    avatar: "",
    lastLogin: "",
    profile: undefined,
    instructorProfile: undefined,
    socials: [],
    updatedAt: "",
    createdAt: "",
  };
}

export const UserData: MessageFns<UserData> = {
  encode(message: UserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.lastName !== "") {
      writer.uint32(50).string(message.lastName);
    }
    if (message.username !== "") {
      writer.uint32(58).string(message.username);
    }
    if (message.slug !== "") {
      writer.uint32(66).string(message.slug);
    }
    if (message.avatar !== "") {
      writer.uint32(74).string(message.avatar);
    }
    if (message.lastLogin !== "") {
      writer.uint32(82).string(message.lastLogin);
    }
    if (message.profile !== undefined) {
      UserProfileData.encode(message.profile, writer.uint32(90).fork()).join();
    }
    if (message.instructorProfile !== undefined) {
      InstructorProfileData.encode(message.instructorProfile, writer.uint32(98).fork()).join();
    }
    for (const v of message.socials) {
      UserSocialsData.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lastLogin = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profile = UserProfileData.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.instructorProfile = InstructorProfileData.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.socials.push(UserSocialsData.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      lastLogin: isSet(object.lastLogin) ? globalThis.String(object.lastLogin) : "",
      profile: isSet(object.profile) ? UserProfileData.fromJSON(object.profile) : undefined,
      instructorProfile: isSet(object.instructorProfile)
        ? InstructorProfileData.fromJSON(object.instructorProfile)
        : undefined,
      socials: globalThis.Array.isArray(object?.socials)
        ? object.socials.map((e: any) => UserSocialsData.fromJSON(e))
        : [],
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: UserData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.lastLogin !== "") {
      obj.lastLogin = message.lastLogin;
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfileData.toJSON(message.profile);
    }
    if (message.instructorProfile !== undefined) {
      obj.instructorProfile = InstructorProfileData.toJSON(message.instructorProfile);
    }
    if (message.socials?.length) {
      obj.socials = message.socials.map((e) => UserSocialsData.toJSON(e));
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserData>, I>>(base?: I): UserData {
    return UserData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserData>, I>>(object: I): UserData {
    const message = createBaseUserData();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.firstName = object.firstName ?? "";
    message.status = object.status ?? "";
    message.lastName = object.lastName ?? "";
    message.username = object.username ?? "";
    message.slug = object.slug ?? "";
    message.avatar = object.avatar ?? "";
    message.lastLogin = object.lastLogin ?? "";
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfileData.fromPartial(object.profile)
      : undefined;
    message.instructorProfile = (object.instructorProfile !== undefined && object.instructorProfile !== null)
      ? InstructorProfileData.fromPartial(object.instructorProfile)
      : undefined;
    message.socials = object.socials?.map((e) => UserSocialsData.fromPartial(e)) || [];
    message.updatedAt = object.updatedAt ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseGetUsersRequest(): GetUsersRequest {
  return { pagination: undefined, filter: undefined, sort: undefined };
}

export const GetUsersRequest: MessageFns<GetUsersRequest> = {
  encode(message: GetUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    if (message.filter !== undefined) {
      UserFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    if (message.sort !== undefined) {
      SortOption.encode(message.sort, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = UserFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sort = SortOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersRequest {
    return {
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
      filter: isSet(object.filter) ? UserFilter.fromJSON(object.filter) : undefined,
      sort: isSet(object.sort) ? SortOption.fromJSON(object.sort) : undefined,
    };
  },

  toJSON(message: GetUsersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    if (message.filter !== undefined) {
      obj.filter = UserFilter.toJSON(message.filter);
    }
    if (message.sort !== undefined) {
      obj.sort = SortOption.toJSON(message.sort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersRequest>, I>>(base?: I): GetUsersRequest {
    return GetUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersRequest>, I>>(object: I): GetUsersRequest {
    const message = createBaseGetUsersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? UserFilter.fromPartial(object.filter)
      : undefined;
    message.sort = (object.sort !== undefined && object.sort !== null)
      ? SortOption.fromPartial(object.sort)
      : undefined;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { userId: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUsersByIdsRequest(): GetUsersByIdsRequest {
  return { userIds: [] };
}

export const GetUsersByIdsRequest: MessageFns<GetUsersByIdsRequest> = {
  encode(message: GetUsersByIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersByIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersByIdsRequest {
    return {
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetUsersByIdsRequest): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersByIdsRequest>, I>>(base?: I): GetUsersByIdsRequest {
    return GetUsersByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersByIdsRequest>, I>>(object: I): GetUsersByIdsRequest {
    const message = createBaseGetUsersByIdsRequest();
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInstructorByNameRequest(): GetInstructorByNameRequest {
  return { username: "" };
}

export const GetInstructorByNameRequest: MessageFns<GetInstructorByNameRequest> = {
  encode(message: GetInstructorByNameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstructorByNameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstructorByNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstructorByNameRequest {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: GetInstructorByNameRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstructorByNameRequest>, I>>(base?: I): GetInstructorByNameRequest {
    return GetInstructorByNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstructorByNameRequest>, I>>(object: I): GetInstructorByNameRequest {
    const message = createBaseGetInstructorByNameRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetUserEmailsRequest(): GetUserEmailsRequest {
  return {};
}

export const GetUserEmailsRequest: MessageFns<GetUserEmailsRequest> = {
  encode(_: GetUserEmailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEmailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEmailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetUserEmailsRequest {
    return {};
  },

  toJSON(_: GetUserEmailsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserEmailsRequest>, I>>(base?: I): GetUserEmailsRequest {
    return GetUserEmailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserEmailsRequest>, I>>(_: I): GetUserEmailsRequest {
    const message = createBaseGetUserEmailsRequest();
    return message;
  },
};

function createBaseCheckUserByEmailRequest(): CheckUserByEmailRequest {
  return { email: "" };
}

export const CheckUserByEmailRequest: MessageFns<CheckUserByEmailRequest> = {
  encode(message: CheckUserByEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: CheckUserByEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(base?: I): CheckUserByEmailRequest {
    return CheckUserByEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(object: I): CheckUserByEmailRequest {
    const message = createBaseCheckUserByEmailRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGetCurrentUserRequest(): GetCurrentUserRequest {
  return { userId: "" };
}

export const GetCurrentUserRequest: MessageFns<GetCurrentUserRequest> = {
  encode(message: GetCurrentUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetCurrentUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentUserRequest>, I>>(base?: I): GetCurrentUserRequest {
    return GetCurrentUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentUserRequest>, I>>(object: I): GetCurrentUserRequest {
    const message = createBaseGetCurrentUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: "" };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUnBlockUserRequest(): UnBlockUserRequest {
  return { userId: "" };
}

export const UnBlockUserRequest: MessageFns<UnBlockUserRequest> = {
  encode(message: UnBlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: UnBlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(base?: I): UnBlockUserRequest {
    return UnBlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(object: I): UnBlockUserRequest {
    const message = createBaseUnBlockUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUpdateUserDetailsRequest(): UpdateUserDetailsRequest {
  return {
    userId: "",
    firstName: undefined,
    lastName: undefined,
    phone: undefined,
    socials: [],
    biography: undefined,
    avatar: undefined,
    website: undefined,
    language: undefined,
    city: undefined,
    country: undefined,
    gender: undefined,
  };
}

export const UpdateUserDetailsRequest: MessageFns<UpdateUserDetailsRequest> = {
  encode(message: UpdateUserDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== undefined) {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(26).string(message.lastName);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    for (const v of message.socials) {
      UserSocialsData.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.biography !== undefined) {
      writer.uint32(50).string(message.biography);
    }
    if (message.avatar !== undefined) {
      writer.uint32(58).string(message.avatar);
    }
    if (message.website !== undefined) {
      writer.uint32(66).string(message.website);
    }
    if (message.language !== undefined) {
      writer.uint32(74).string(message.language);
    }
    if (message.city !== undefined) {
      writer.uint32(82).string(message.city);
    }
    if (message.country !== undefined) {
      writer.uint32(90).string(message.country);
    }
    if (message.gender !== undefined) {
      writer.uint32(98).string(message.gender);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.socials.push(UserSocialsData.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.biography = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      socials: globalThis.Array.isArray(object?.socials)
        ? object.socials.map((e: any) => UserSocialsData.fromJSON(e))
        : [],
      biography: isSet(object.biography) ? globalThis.String(object.biography) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
      website: isSet(object.website) ? globalThis.String(object.website) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      city: isSet(object.city) ? globalThis.String(object.city) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : undefined,
    };
  },

  toJSON(message: UpdateUserDetailsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.socials?.length) {
      obj.socials = message.socials.map((e) => UserSocialsData.toJSON(e));
    }
    if (message.biography !== undefined) {
      obj.biography = message.biography;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.city !== undefined) {
      obj.city = message.city;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.gender !== undefined) {
      obj.gender = message.gender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(base?: I): UpdateUserDetailsRequest {
    return UpdateUserDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(object: I): UpdateUserDetailsRequest {
    const message = createBaseUpdateUserDetailsRequest();
    message.userId = object.userId ?? "";
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.phone = object.phone ?? undefined;
    message.socials = object.socials?.map((e) => UserSocialsData.fromPartial(e)) || [];
    message.biography = object.biography ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.website = object.website ?? undefined;
    message.language = object.language ?? undefined;
    message.city = object.city ?? undefined;
    message.country = object.country ?? undefined;
    message.gender = object.gender ?? undefined;
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { userId: "", oldPassword: "", newPassword: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.userId = object.userId ?? "";
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseRegisterInstructorRequest(): RegisterInstructorRequest {
  return {
    userId: "",
    username: "",
    tags: [],
    expertise: "",
    experience: "",
    education: "",
    language: "",
    headline: "",
    biography: "",
    agreeToTerms: false,
    agreeToPrivacy: false,
    receiveUpdates: false,
  };
}

export const RegisterInstructorRequest: MessageFns<RegisterInstructorRequest> = {
  encode(message: RegisterInstructorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.expertise !== "") {
      writer.uint32(34).string(message.expertise);
    }
    if (message.experience !== "") {
      writer.uint32(42).string(message.experience);
    }
    if (message.education !== "") {
      writer.uint32(50).string(message.education);
    }
    if (message.language !== "") {
      writer.uint32(58).string(message.language);
    }
    if (message.headline !== "") {
      writer.uint32(66).string(message.headline);
    }
    if (message.biography !== "") {
      writer.uint32(74).string(message.biography);
    }
    if (message.agreeToTerms !== false) {
      writer.uint32(80).bool(message.agreeToTerms);
    }
    if (message.agreeToPrivacy !== false) {
      writer.uint32(88).bool(message.agreeToPrivacy);
    }
    if (message.receiveUpdates !== false) {
      writer.uint32(96).bool(message.receiveUpdates);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInstructorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInstructorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expertise = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.experience = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.education = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.headline = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.biography = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.agreeToTerms = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.agreeToPrivacy = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.receiveUpdates = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInstructorRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      expertise: isSet(object.expertise) ? globalThis.String(object.expertise) : "",
      experience: isSet(object.experience) ? globalThis.String(object.experience) : "",
      education: isSet(object.education) ? globalThis.String(object.education) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      headline: isSet(object.headline) ? globalThis.String(object.headline) : "",
      biography: isSet(object.biography) ? globalThis.String(object.biography) : "",
      agreeToTerms: isSet(object.agreeToTerms) ? globalThis.Boolean(object.agreeToTerms) : false,
      agreeToPrivacy: isSet(object.agreeToPrivacy) ? globalThis.Boolean(object.agreeToPrivacy) : false,
      receiveUpdates: isSet(object.receiveUpdates) ? globalThis.Boolean(object.receiveUpdates) : false,
    };
  },

  toJSON(message: RegisterInstructorRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.expertise !== "") {
      obj.expertise = message.expertise;
    }
    if (message.experience !== "") {
      obj.experience = message.experience;
    }
    if (message.education !== "") {
      obj.education = message.education;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.headline !== "") {
      obj.headline = message.headline;
    }
    if (message.biography !== "") {
      obj.biography = message.biography;
    }
    if (message.agreeToTerms !== false) {
      obj.agreeToTerms = message.agreeToTerms;
    }
    if (message.agreeToPrivacy !== false) {
      obj.agreeToPrivacy = message.agreeToPrivacy;
    }
    if (message.receiveUpdates !== false) {
      obj.receiveUpdates = message.receiveUpdates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(base?: I): RegisterInstructorRequest {
    return RegisterInstructorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(object: I): RegisterInstructorRequest {
    const message = createBaseRegisterInstructorRequest();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.expertise = object.expertise ?? "";
    message.experience = object.experience ?? "";
    message.education = object.education ?? "";
    message.language = object.language ?? "";
    message.headline = object.headline ?? "";
    message.biography = object.biography ?? "";
    message.agreeToTerms = object.agreeToTerms ?? false;
    message.agreeToPrivacy = object.agreeToPrivacy ?? false;
    message.receiveUpdates = object.receiveUpdates ?? false;
    return message;
  },
};

function createBaseUserEmailsSuccess(): UserEmailsSuccess {
  return { email: [] };
}

export const UserEmailsSuccess: MessageFns<UserEmailsSuccess> = {
  encode(message: UserEmailsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.email) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEmailsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEmailsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEmailsSuccess {
    return { email: globalThis.Array.isArray(object?.email) ? object.email.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: UserEmailsSuccess): unknown {
    const obj: any = {};
    if (message.email?.length) {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserEmailsSuccess>, I>>(base?: I): UserEmailsSuccess {
    return UserEmailsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserEmailsSuccess>, I>>(object: I): UserEmailsSuccess {
    const message = createBaseUserEmailsSuccess();
    message.email = object.email?.map((e) => e) || [];
    return message;
  },
};

function createBaseEmailExist(): EmailExist {
  return { success: "", error: "" };
}

export const EmailExist: MessageFns<EmailExist> = {
  encode(message: EmailExist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== "") {
      writer.uint32(10).string(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailExist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailExist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailExist {
    return {
      success: isSet(object.success) ? globalThis.String(object.success) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: EmailExist): unknown {
    const obj: any = {};
    if (message.success !== "") {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailExist>, I>>(base?: I): EmailExist {
    return EmailExist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailExist>, I>>(object: I): EmailExist {
    const message = createBaseEmailExist();
    message.success = object.success ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseUsersSuccess(): UsersSuccess {
  return { users: [], pagination: undefined };
}

export const UsersSuccess: MessageFns<UsersSuccess> = {
  encode(message: UsersSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersSuccess {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => UserData.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: UsersSuccess): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersSuccess>, I>>(base?: I): UsersSuccess {
    return UsersSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersSuccess>, I>>(object: I): UsersSuccess {
    const message = createBaseUsersSuccess();
    message.users = object.users?.map((e) => UserData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseUsersResponse(): UsersResponse {
  return { users: [] };
}

export const UsersResponse: MessageFns<UsersResponse> = {
  encode(message: UsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersResponse {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => UserData.fromJSON(e)) : [] };
  },

  toJSON(message: UsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersResponse>, I>>(base?: I): UsersResponse {
    return UsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersResponse>, I>>(object: I): UsersResponse {
    const message = createBaseUsersResponse();
    message.users = object.users?.map((e) => UserData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetUsersResponse(): GetUsersResponse {
  return { success: undefined, error: undefined };
}

export const GetUsersResponse: MessageFns<GetUsersResponse> = {
  encode(message: GetUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UsersSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UsersSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersResponse {
    return {
      success: isSet(object.success) ? UsersSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUsersResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UsersSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersResponse>, I>>(base?: I): GetUsersResponse {
    return GetUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersResponse>, I>>(object: I): GetUsersResponse {
    const message = createBaseGetUsersResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? UsersSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetUserEmailsResponse(): GetUserEmailsResponse {
  return { success: undefined, error: undefined };
}

export const GetUserEmailsResponse: MessageFns<GetUserEmailsResponse> = {
  encode(message: GetUserEmailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UserEmailsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEmailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEmailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UserEmailsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserEmailsResponse {
    return {
      success: isSet(object.success) ? UserEmailsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUserEmailsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UserEmailsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserEmailsResponse>, I>>(base?: I): GetUserEmailsResponse {
    return GetUserEmailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserEmailsResponse>, I>>(object: I): GetUserEmailsResponse {
    const message = createBaseGetUserEmailsResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? UserEmailsSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetUsersByIdsResponse(): GetUsersByIdsResponse {
  return { success: undefined, error: undefined };
}

export const GetUsersByIdsResponse: MessageFns<GetUsersByIdsResponse> = {
  encode(message: GetUsersByIdsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UsersResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersByIdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersByIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UsersResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersByIdsResponse {
    return {
      success: isSet(object.success) ? UsersResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUsersByIdsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UsersResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersByIdsResponse>, I>>(base?: I): GetUsersByIdsResponse {
    return GetUsersByIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersByIdsResponse>, I>>(object: I): GetUsersByIdsResponse {
    const message = createBaseGetUsersByIdsResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? UsersResponse.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined, error: undefined };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserData.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      user: isSet(object.user) ? UserData.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserData.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserData.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetInstructorByNameResponse(): GetInstructorByNameResponse {
  return { user: undefined, error: undefined };
}

export const GetInstructorByNameResponse: MessageFns<GetInstructorByNameResponse> = {
  encode(message: GetInstructorByNameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserData.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstructorByNameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstructorByNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstructorByNameResponse {
    return {
      user: isSet(object.user) ? UserData.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetInstructorByNameResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserData.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstructorByNameResponse>, I>>(base?: I): GetInstructorByNameResponse {
    return GetInstructorByNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstructorByNameResponse>, I>>(object: I): GetInstructorByNameResponse {
    const message = createBaseGetInstructorByNameResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserData.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetCurrentUserResponse(): GetCurrentUserResponse {
  return { user: undefined, error: undefined };
}

export const GetCurrentUserResponse: MessageFns<GetCurrentUserResponse> = {
  encode(message: GetCurrentUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserData.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentUserResponse {
    return {
      user: isSet(object.user) ? UserData.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetCurrentUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserData.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentUserResponse>, I>>(base?: I): GetCurrentUserResponse {
    return GetCurrentUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentUserResponse>, I>>(object: I): GetCurrentUserResponse {
    const message = createBaseGetCurrentUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserData.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseCheckUserByEmailResponse(): CheckUserByEmailResponse {
  return { response: undefined, error: undefined };
}

export const CheckUserByEmailResponse: MessageFns<CheckUserByEmailResponse> = {
  encode(message: CheckUserByEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      EmailExist.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = EmailExist.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailResponse {
    return {
      response: isSet(object.response) ? EmailExist.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CheckUserByEmailResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = EmailExist.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(base?: I): CheckUserByEmailResponse {
    return CheckUserByEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(object: I): CheckUserByEmailResponse {
    const message = createBaseCheckUserByEmailResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? EmailExist.fromPartial(object.response)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserResponse(): BlockUserResponse {
  return { success: undefined, error: undefined };
}

export const BlockUserResponse: MessageFns<BlockUserResponse> = {
  encode(message: BlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      BlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = BlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserResponse {
    return {
      success: isSet(object.success) ? BlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = BlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserResponse>, I>>(base?: I): BlockUserResponse {
    return BlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserResponse>, I>>(object: I): BlockUserResponse {
    const message = createBaseBlockUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? BlockUserSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseUnBlockUserResponse(): UnBlockUserResponse {
  return { success: undefined, error: undefined };
}

export const UnBlockUserResponse: MessageFns<UnBlockUserResponse> = {
  encode(message: UnBlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UnBlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UnBlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserResponse {
    return {
      success: isSet(object.success) ? UnBlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UnBlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UnBlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(base?: I): UnBlockUserResponse {
    return UnBlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(object: I): UnBlockUserResponse {
    const message = createBaseUnBlockUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? UnBlockUserSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserSuccess(): BlockUserSuccess {
  return { updated: false };
}

export const BlockUserSuccess: MessageFns<BlockUserSuccess> = {
  encode(message: BlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: BlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(base?: I): BlockUserSuccess {
    return BlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(object: I): BlockUserSuccess {
    const message = createBaseBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseUnBlockUserSuccess(): UnBlockUserSuccess {
  return { updated: false };
}

export const UnBlockUserSuccess: MessageFns<UnBlockUserSuccess> = {
  encode(message: UnBlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: UnBlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(base?: I): UnBlockUserSuccess {
    return UnBlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(object: I): UnBlockUserSuccess {
    const message = createBaseUnBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseUpdateUserDetailsResponse(): UpdateUserDetailsResponse {
  return { user: undefined, error: undefined };
}

export const UpdateUserDetailsResponse: MessageFns<UpdateUserDetailsResponse> = {
  encode(message: UpdateUserDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserData.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsResponse {
    return {
      user: isSet(object.user) ? UserData.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UpdateUserDetailsResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserData.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(base?: I): UpdateUserDetailsResponse {
    return UpdateUserDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(object: I): UpdateUserDetailsResponse {
    const message = createBaseUpdateUserDetailsResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserData.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseChangePasswordResponse(): ChangePasswordResponse {
  return { success: undefined, error: undefined };
}

export const ChangePasswordResponse: MessageFns<ChangePasswordResponse> = {
  encode(message: ChangePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ChangePasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ChangePasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordResponse {
    return {
      success: isSet(object.success) ? ChangePasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ChangePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ChangePasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(base?: I): ChangePasswordResponse {
    return ChangePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(object: I): ChangePasswordResponse {
    const message = createBaseChangePasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ChangePasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseChangePasswordSuccess(): ChangePasswordSuccess {
  return { updated: false };
}

export const ChangePasswordSuccess: MessageFns<ChangePasswordSuccess> = {
  encode(message: ChangePasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: ChangePasswordSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(base?: I): ChangePasswordSuccess {
    return ChangePasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(object: I): ChangePasswordSuccess {
    const message = createBaseChangePasswordSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
