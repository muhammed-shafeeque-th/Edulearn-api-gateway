// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.33.1
// source: notification.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'notification';

/** Structured error message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

export interface ErrorDetail {
  field: string;
  message: string;
}

export interface VerifyOTPRequest {
  /** Email address */
  email: string;
  /** OTP code to verify */
  otp: string;
}

export interface ForgotPasswordRequest {
  /** User ID */
  username: string;
  /** User ID */
  userId: string;
  /** Email address */
  email: string;
  /** Password reset link, */
  resetLink: string;
}

export interface OTPRequest {
  userId: string;
  email: string;
  username: string;
}

export interface GetNotificationRequest {
  notificationId: string;
  userId: string;
}

export interface DeleteNotificationRequest {
  notificationId: string;
  userId: string;
}

export interface ClearUserNotificationsRequest {
  userId: string;
}

export interface NotificationParams {
  page: number;
  pageSize: number;
  /** Filter by read status */
  isRead: boolean;
  /** Filter by notification type */
  category: string;
}

export interface GetNotificationsRequest {
  userId: string;
  params: NotificationParams | undefined;
}

export interface MarkNotificationRequest {
  notificationId: string;
  userId: string;
}

export interface MarkAllNotificationsRequest {
  userId: string;
}

/** Updated response messages with oneof for error handling */
export interface NotificationResponse {
  success?: NotificationSuccess | undefined;
  error?: Error | undefined;
}

export interface NotificationSuccess {
  success: boolean;
  message: string;
}

export interface NotificationData {
  id: string;
  type: string;
  userId: string;
  subject: string;
  body: string;
  recipient: string;
  isRead: boolean;
  createdAt: string;
  priority: string;
  actionUrl: string;
  category: string;
  metadata: { [key: string]: string };
}

export interface NotificationData_MetadataEntry {
  key: string;
  value: string;
}

export interface GetNotificationResponse {
  notification?: NotificationData | undefined;
  error?: Error | undefined;
}

export interface DeleteNotificationResponse {
  success?: DeleteSuccess | undefined;
  error?: Error | undefined;
}

export interface ClearUserNotificationsResponse {
  success?: DeleteSuccess | undefined;
  error?: Error | undefined;
}

export interface DeleteSuccess {
  success: boolean;
}

export interface GetNotificationsResponse {
  success?: GetAllNotificationsSuccess | undefined;
  error?: Error | undefined;
}

export interface GetAllNotificationsSuccess {
  notifications: NotificationData[];
  total: number;
}

function createBaseError(): Error {
  return { code: '', message: '', details: [] };
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.code !== '') {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => ErrorDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== '') {
      obj.code = message.code;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.details?.length) {
      obj.details = message.details.map(e => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? '';
    message.message = object.message ?? '';
    message.details =
      object.details?.map(e => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: '', message: '' };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(
    message: ErrorDetail,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.field !== '') {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== '') {
      obj.field = message.field;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(
    object: I
  ): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? '';
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseVerifyOTPRequest(): VerifyOTPRequest {
  return { email: '', otp: '' };
}

export const VerifyOTPRequest: MessageFns<VerifyOTPRequest> = {
  encode(
    message: VerifyOTPRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.otp !== '') {
      writer.uint32(26).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyOTPRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyOTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyOTPRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      otp: isSet(object.otp) ? globalThis.String(object.otp) : '',
    };
  },

  toJSON(message: VerifyOTPRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.otp !== '') {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyOTPRequest>, I>>(
    base?: I
  ): VerifyOTPRequest {
    return VerifyOTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyOTPRequest>, I>>(
    object: I
  ): VerifyOTPRequest {
    const message = createBaseVerifyOTPRequest();
    message.email = object.email ?? '';
    message.otp = object.otp ?? '';
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { username: '', userId: '', email: '', resetLink: '' };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(
    message: ForgotPasswordRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.username !== '') {
      writer.uint32(10).string(message.username);
    }
    if (message.userId !== '') {
      writer.uint32(42).string(message.userId);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.resetLink !== '') {
      writer.uint32(26).string(message.resetLink);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ForgotPasswordRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resetLink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return {
      username: isSet(object.username)
        ? globalThis.String(object.username)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      resetLink: isSet(object.resetLink)
        ? globalThis.String(object.resetLink)
        : '',
    };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.resetLink !== '') {
      obj.resetLink = message.resetLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(
    base?: I
  ): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(
    object: I
  ): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.username = object.username ?? '';
    message.userId = object.userId ?? '';
    message.email = object.email ?? '';
    message.resetLink = object.resetLink ?? '';
    return message;
  },
};

function createBaseOTPRequest(): OTPRequest {
  return { userId: '', email: '', username: '' };
}

export const OTPRequest: MessageFns<OTPRequest> = {
  encode(
    message: OTPRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.username !== '') {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OTPRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OTPRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      username: isSet(object.username)
        ? globalThis.String(object.username)
        : '',
    };
  },

  toJSON(message: OTPRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.username !== '') {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OTPRequest>, I>>(base?: I): OTPRequest {
    return OTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OTPRequest>, I>>(
    object: I
  ): OTPRequest {
    const message = createBaseOTPRequest();
    message.userId = object.userId ?? '';
    message.email = object.email ?? '';
    message.username = object.username ?? '';
    return message;
  },
};

function createBaseGetNotificationRequest(): GetNotificationRequest {
  return { notificationId: '', userId: '' };
}

export const GetNotificationRequest: MessageFns<GetNotificationRequest> = {
  encode(
    message: GetNotificationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.notificationId !== '') {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetNotificationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationRequest {
    return {
      notificationId: isSet(object.notificationId)
        ? globalThis.String(object.notificationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: GetNotificationRequest): unknown {
    const obj: any = {};
    if (message.notificationId !== '') {
      obj.notificationId = message.notificationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationRequest>, I>>(
    base?: I
  ): GetNotificationRequest {
    return GetNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationRequest>, I>>(
    object: I
  ): GetNotificationRequest {
    const message = createBaseGetNotificationRequest();
    message.notificationId = object.notificationId ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseDeleteNotificationRequest(): DeleteNotificationRequest {
  return { notificationId: '', userId: '' };
}

export const DeleteNotificationRequest: MessageFns<DeleteNotificationRequest> =
  {
    encode(
      message: DeleteNotificationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.notificationId !== '') {
        writer.uint32(10).string(message.notificationId);
      }
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): DeleteNotificationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDeleteNotificationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.notificationId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DeleteNotificationRequest {
      return {
        notificationId: isSet(object.notificationId)
          ? globalThis.String(object.notificationId)
          : '',
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: DeleteNotificationRequest): unknown {
      const obj: any = {};
      if (message.notificationId !== '') {
        obj.notificationId = message.notificationId;
      }
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<DeleteNotificationRequest>, I>>(
      base?: I
    ): DeleteNotificationRequest {
      return DeleteNotificationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DeleteNotificationRequest>, I>>(
      object: I
    ): DeleteNotificationRequest {
      const message = createBaseDeleteNotificationRequest();
      message.notificationId = object.notificationId ?? '';
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseClearUserNotificationsRequest(): ClearUserNotificationsRequest {
  return { userId: '' };
}

export const ClearUserNotificationsRequest: MessageFns<ClearUserNotificationsRequest> =
  {
    encode(
      message: ClearUserNotificationsRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): ClearUserNotificationsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClearUserNotificationsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClearUserNotificationsRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: ClearUserNotificationsRequest): unknown {
      const obj: any = {};
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ClearUserNotificationsRequest>, I>>(
      base?: I
    ): ClearUserNotificationsRequest {
      return ClearUserNotificationsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ClearUserNotificationsRequest>, I>>(
      object: I
    ): ClearUserNotificationsRequest {
      const message = createBaseClearUserNotificationsRequest();
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseNotificationParams(): NotificationParams {
  return { page: 0, pageSize: 0, isRead: false, category: '' };
}

export const NotificationParams: MessageFns<NotificationParams> = {
  encode(
    message: NotificationParams,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.isRead !== false) {
      writer.uint32(32).bool(message.isRead);
    }
    if (message.category !== '') {
      writer.uint32(42).string(message.category);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NotificationParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRead = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationParams {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      isRead: isSet(object.isRead) ? globalThis.Boolean(object.isRead) : false,
      category: isSet(object.category)
        ? globalThis.String(object.category)
        : '',
    };
  },

  toJSON(message: NotificationParams): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.isRead !== false) {
      obj.isRead = message.isRead;
    }
    if (message.category !== '') {
      obj.category = message.category;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationParams>, I>>(
    base?: I
  ): NotificationParams {
    return NotificationParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationParams>, I>>(
    object: I
  ): NotificationParams {
    const message = createBaseNotificationParams();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.isRead = object.isRead ?? false;
    message.category = object.category ?? '';
    return message;
  },
};

function createBaseGetNotificationsRequest(): GetNotificationsRequest {
  return { userId: '', params: undefined };
}

export const GetNotificationsRequest: MessageFns<GetNotificationsRequest> = {
  encode(
    message: GetNotificationsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.params !== undefined) {
      NotificationParams.encode(
        message.params,
        writer.uint32(18).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetNotificationsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = NotificationParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      params: isSet(object.params)
        ? NotificationParams.fromJSON(object.params)
        : undefined,
    };
  },

  toJSON(message: GetNotificationsRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.params !== undefined) {
      obj.params = NotificationParams.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationsRequest>, I>>(
    base?: I
  ): GetNotificationsRequest {
    return GetNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationsRequest>, I>>(
    object: I
  ): GetNotificationsRequest {
    const message = createBaseGetNotificationsRequest();
    message.userId = object.userId ?? '';
    message.params =
      object.params !== undefined && object.params !== null
        ? NotificationParams.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseMarkNotificationRequest(): MarkNotificationRequest {
  return { notificationId: '', userId: '' };
}

export const MarkNotificationRequest: MessageFns<MarkNotificationRequest> = {
  encode(
    message: MarkNotificationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.notificationId !== '') {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): MarkNotificationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkNotificationRequest {
    return {
      notificationId: isSet(object.notificationId)
        ? globalThis.String(object.notificationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: MarkNotificationRequest): unknown {
    const obj: any = {};
    if (message.notificationId !== '') {
      obj.notificationId = message.notificationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkNotificationRequest>, I>>(
    base?: I
  ): MarkNotificationRequest {
    return MarkNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkNotificationRequest>, I>>(
    object: I
  ): MarkNotificationRequest {
    const message = createBaseMarkNotificationRequest();
    message.notificationId = object.notificationId ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseMarkAllNotificationsRequest(): MarkAllNotificationsRequest {
  return { userId: '' };
}

export const MarkAllNotificationsRequest: MessageFns<MarkAllNotificationsRequest> =
  {
    encode(
      message: MarkAllNotificationsRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== '') {
        writer.uint32(10).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): MarkAllNotificationsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMarkAllNotificationsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MarkAllNotificationsRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: MarkAllNotificationsRequest): unknown {
      const obj: any = {};
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MarkAllNotificationsRequest>, I>>(
      base?: I
    ): MarkAllNotificationsRequest {
      return MarkAllNotificationsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MarkAllNotificationsRequest>, I>>(
      object: I
    ): MarkAllNotificationsRequest {
      const message = createBaseMarkAllNotificationsRequest();
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseNotificationResponse(): NotificationResponse {
  return { success: undefined, error: undefined };
}

export const NotificationResponse: MessageFns<NotificationResponse> = {
  encode(
    message: NotificationResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== undefined) {
      NotificationSuccess.encode(
        message.success,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NotificationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = NotificationSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationResponse {
    return {
      success: isSet(object.success)
        ? NotificationSuccess.fromJSON(object.success)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: NotificationResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = NotificationSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationResponse>, I>>(
    base?: I
  ): NotificationResponse {
    return NotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationResponse>, I>>(
    object: I
  ): NotificationResponse {
    const message = createBaseNotificationResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? NotificationSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseNotificationSuccess(): NotificationSuccess {
  return { success: false, message: '' };
}

export const NotificationSuccess: MessageFns<NotificationSuccess> = {
  encode(
    message: NotificationSuccess,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NotificationSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSuccess {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: NotificationSuccess): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationSuccess>, I>>(
    base?: I
  ): NotificationSuccess {
    return NotificationSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationSuccess>, I>>(
    object: I
  ): NotificationSuccess {
    const message = createBaseNotificationSuccess();
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseNotificationData(): NotificationData {
  return {
    id: '',
    type: '',
    userId: '',
    subject: '',
    body: '',
    recipient: '',
    isRead: false,
    createdAt: '',
    priority: '',
    actionUrl: '',
    category: '',
    metadata: {},
  };
}

export const NotificationData: MessageFns<NotificationData> = {
  encode(
    message: NotificationData,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== '') {
      writer.uint32(26).string(message.type);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.subject !== '') {
      writer.uint32(34).string(message.subject);
    }
    if (message.body !== '') {
      writer.uint32(42).string(message.body);
    }
    if (message.recipient !== '') {
      writer.uint32(50).string(message.recipient);
    }
    if (message.isRead !== false) {
      writer.uint32(56).bool(message.isRead);
    }
    if (message.createdAt !== '') {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.priority !== '') {
      writer.uint32(74).string(message.priority);
    }
    if (message.actionUrl !== '') {
      writer.uint32(82).string(message.actionUrl);
    }
    if (message.category !== '') {
      writer.uint32(90).string(message.category);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      NotificationData_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(98).fork()
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isRead = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.actionUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = NotificationData_MetadataEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry12.value !== undefined) {
            message.metadata[entry12.key] = entry12.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      subject: isSet(object.subject) ? globalThis.String(object.subject) : '',
      body: isSet(object.body) ? globalThis.String(object.body) : '',
      recipient: isSet(object.recipient)
        ? globalThis.String(object.recipient)
        : '',
      isRead: isSet(object.isRead) ? globalThis.Boolean(object.isRead) : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : '',
      priority: isSet(object.priority)
        ? globalThis.String(object.priority)
        : '',
      actionUrl: isSet(object.actionUrl)
        ? globalThis.String(object.actionUrl)
        : '',
      category: isSet(object.category)
        ? globalThis.String(object.category)
        : '',
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {}
          )
        : {},
    };
  },

  toJSON(message: NotificationData): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.subject !== '') {
      obj.subject = message.subject;
    }
    if (message.body !== '') {
      obj.body = message.body;
    }
    if (message.recipient !== '') {
      obj.recipient = message.recipient;
    }
    if (message.isRead !== false) {
      obj.isRead = message.isRead;
    }
    if (message.createdAt !== '') {
      obj.createdAt = message.createdAt;
    }
    if (message.priority !== '') {
      obj.priority = message.priority;
    }
    if (message.actionUrl !== '') {
      obj.actionUrl = message.actionUrl;
    }
    if (message.category !== '') {
      obj.category = message.category;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationData>, I>>(
    base?: I
  ): NotificationData {
    return NotificationData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationData>, I>>(
    object: I
  ): NotificationData {
    const message = createBaseNotificationData();
    message.id = object.id ?? '';
    message.type = object.type ?? '';
    message.userId = object.userId ?? '';
    message.subject = object.subject ?? '';
    message.body = object.body ?? '';
    message.recipient = object.recipient ?? '';
    message.isRead = object.isRead ?? false;
    message.createdAt = object.createdAt ?? '';
    message.priority = object.priority ?? '';
    message.actionUrl = object.actionUrl ?? '';
    message.category = object.category ?? '';
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseNotificationData_MetadataEntry(): NotificationData_MetadataEntry {
  return { key: '', value: '' };
}

export const NotificationData_MetadataEntry: MessageFns<NotificationData_MetadataEntry> =
  {
    encode(
      message: NotificationData_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== '') {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): NotificationData_MetadataEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNotificationData_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NotificationData_MetadataEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : '',
        value: isSet(object.value) ? globalThis.String(object.value) : '',
      };
    },

    toJSON(message: NotificationData_MetadataEntry): unknown {
      const obj: any = {};
      if (message.key !== '') {
        obj.key = message.key;
      }
      if (message.value !== '') {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<NotificationData_MetadataEntry>, I>>(
      base?: I
    ): NotificationData_MetadataEntry {
      return NotificationData_MetadataEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<NotificationData_MetadataEntry>, I>,
    >(object: I): NotificationData_MetadataEntry {
      const message = createBaseNotificationData_MetadataEntry();
      message.key = object.key ?? '';
      message.value = object.value ?? '';
      return message;
    },
  };

function createBaseGetNotificationResponse(): GetNotificationResponse {
  return { notification: undefined, error: undefined };
}

export const GetNotificationResponse: MessageFns<GetNotificationResponse> = {
  encode(
    message: GetNotificationResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.notification !== undefined) {
      NotificationData.encode(
        message.notification,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetNotificationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notification = NotificationData.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationResponse {
    return {
      notification: isSet(object.notification)
        ? NotificationData.fromJSON(object.notification)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetNotificationResponse): unknown {
    const obj: any = {};
    if (message.notification !== undefined) {
      obj.notification = NotificationData.toJSON(message.notification);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationResponse>, I>>(
    base?: I
  ): GetNotificationResponse {
    return GetNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationResponse>, I>>(
    object: I
  ): GetNotificationResponse {
    const message = createBaseGetNotificationResponse();
    message.notification =
      object.notification !== undefined && object.notification !== null
        ? NotificationData.fromPartial(object.notification)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseDeleteNotificationResponse(): DeleteNotificationResponse {
  return { success: undefined, error: undefined };
}

export const DeleteNotificationResponse: MessageFns<DeleteNotificationResponse> =
  {
    encode(
      message: DeleteNotificationResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.success !== undefined) {
        DeleteSuccess.encode(message.success, writer.uint32(10).fork()).join();
      }
      if (message.error !== undefined) {
        Error.encode(message.error, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): DeleteNotificationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDeleteNotificationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.success = DeleteSuccess.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.error = Error.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DeleteNotificationResponse {
      return {
        success: isSet(object.success)
          ? DeleteSuccess.fromJSON(object.success)
          : undefined,
        error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      };
    },

    toJSON(message: DeleteNotificationResponse): unknown {
      const obj: any = {};
      if (message.success !== undefined) {
        obj.success = DeleteSuccess.toJSON(message.success);
      }
      if (message.error !== undefined) {
        obj.error = Error.toJSON(message.error);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<DeleteNotificationResponse>, I>>(
      base?: I
    ): DeleteNotificationResponse {
      return DeleteNotificationResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DeleteNotificationResponse>, I>>(
      object: I
    ): DeleteNotificationResponse {
      const message = createBaseDeleteNotificationResponse();
      message.success =
        object.success !== undefined && object.success !== null
          ? DeleteSuccess.fromPartial(object.success)
          : undefined;
      message.error =
        object.error !== undefined && object.error !== null
          ? Error.fromPartial(object.error)
          : undefined;
      return message;
    },
  };

function createBaseClearUserNotificationsResponse(): ClearUserNotificationsResponse {
  return { success: undefined, error: undefined };
}

export const ClearUserNotificationsResponse: MessageFns<ClearUserNotificationsResponse> =
  {
    encode(
      message: ClearUserNotificationsResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.success !== undefined) {
        DeleteSuccess.encode(message.success, writer.uint32(10).fork()).join();
      }
      if (message.error !== undefined) {
        Error.encode(message.error, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): ClearUserNotificationsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClearUserNotificationsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.success = DeleteSuccess.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.error = Error.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClearUserNotificationsResponse {
      return {
        success: isSet(object.success)
          ? DeleteSuccess.fromJSON(object.success)
          : undefined,
        error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      };
    },

    toJSON(message: ClearUserNotificationsResponse): unknown {
      const obj: any = {};
      if (message.success !== undefined) {
        obj.success = DeleteSuccess.toJSON(message.success);
      }
      if (message.error !== undefined) {
        obj.error = Error.toJSON(message.error);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ClearUserNotificationsResponse>, I>>(
      base?: I
    ): ClearUserNotificationsResponse {
      return ClearUserNotificationsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<ClearUserNotificationsResponse>, I>,
    >(object: I): ClearUserNotificationsResponse {
      const message = createBaseClearUserNotificationsResponse();
      message.success =
        object.success !== undefined && object.success !== null
          ? DeleteSuccess.fromPartial(object.success)
          : undefined;
      message.error =
        object.error !== undefined && object.error !== null
          ? Error.fromPartial(object.error)
          : undefined;
      return message;
    },
  };

function createBaseDeleteSuccess(): DeleteSuccess {
  return { success: false };
}

export const DeleteSuccess: MessageFns<DeleteSuccess> = {
  encode(
    message: DeleteSuccess,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSuccess {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
    };
  },

  toJSON(message: DeleteSuccess): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSuccess>, I>>(
    base?: I
  ): DeleteSuccess {
    return DeleteSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSuccess>, I>>(
    object: I
  ): DeleteSuccess {
    const message = createBaseDeleteSuccess();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetNotificationsResponse(): GetNotificationsResponse {
  return { success: undefined, error: undefined };
}

export const GetNotificationsResponse: MessageFns<GetNotificationsResponse> = {
  encode(
    message: GetNotificationsResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== undefined) {
      GetAllNotificationsSuccess.encode(
        message.success,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetNotificationsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = GetAllNotificationsSuccess.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationsResponse {
    return {
      success: isSet(object.success)
        ? GetAllNotificationsSuccess.fromJSON(object.success)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetNotificationsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = GetAllNotificationsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationsResponse>, I>>(
    base?: I
  ): GetNotificationsResponse {
    return GetNotificationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationsResponse>, I>>(
    object: I
  ): GetNotificationsResponse {
    const message = createBaseGetNotificationsResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? GetAllNotificationsSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseGetAllNotificationsSuccess(): GetAllNotificationsSuccess {
  return { notifications: [], total: 0 };
}

export const GetAllNotificationsSuccess: MessageFns<GetAllNotificationsSuccess> =
  {
    encode(
      message: GetAllNotificationsSuccess,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      for (const v of message.notifications) {
        NotificationData.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.total !== 0) {
        writer.uint32(16).int32(message.total);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): GetAllNotificationsSuccess {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAllNotificationsSuccess();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.notifications.push(
              NotificationData.decode(reader, reader.uint32())
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.total = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAllNotificationsSuccess {
      return {
        notifications: globalThis.Array.isArray(object?.notifications)
          ? object.notifications.map((e: any) => NotificationData.fromJSON(e))
          : [],
        total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      };
    },

    toJSON(message: GetAllNotificationsSuccess): unknown {
      const obj: any = {};
      if (message.notifications?.length) {
        obj.notifications = message.notifications.map(e =>
          NotificationData.toJSON(e)
        );
      }
      if (message.total !== 0) {
        obj.total = Math.round(message.total);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAllNotificationsSuccess>, I>>(
      base?: I
    ): GetAllNotificationsSuccess {
      return GetAllNotificationsSuccess.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetAllNotificationsSuccess>, I>>(
      object: I
    ): GetAllNotificationsSuccess {
      const message = createBaseGetAllNotificationsSuccess();
      message.notifications =
        object.notifications?.map(e => NotificationData.fromPartial(e)) || [];
      message.total = object.total ?? 0;
      return message;
    },
  };

export type NotificationServiceService = typeof NotificationServiceService;
export const NotificationServiceService = {
  sendOtp: {
    path: '/notification.NotificationService/SendOTP',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OTPRequest) =>
      Buffer.from(OTPRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OTPRequest.decode(value),
    responseSerialize: (value: NotificationResponse) =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationResponse.decode(value),
  },
  verifyOtp: {
    path: '/notification.NotificationService/VerifyOTP',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyOTPRequest) =>
      Buffer.from(VerifyOTPRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyOTPRequest.decode(value),
    responseSerialize: (value: NotificationResponse) =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationResponse.decode(value),
  },
  forgotPassword: {
    path: '/notification.NotificationService/ForgotPassword',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: NotificationResponse) =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationResponse.decode(value),
  },
  getNotification: {
    path: '/notification.NotificationService/GetNotification',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationRequest) =>
      Buffer.from(GetNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNotificationRequest.decode(value),
    responseSerialize: (value: GetNotificationResponse) =>
      Buffer.from(GetNotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetNotificationResponse.decode(value),
  },
  deleteNotification: {
    path: '/notification.NotificationService/DeleteNotification',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteNotificationRequest) =>
      Buffer.from(DeleteNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      DeleteNotificationRequest.decode(value),
    responseSerialize: (value: DeleteNotificationResponse) =>
      Buffer.from(DeleteNotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      DeleteNotificationResponse.decode(value),
  },
  clearUserNotifications: {
    path: '/notification.NotificationService/ClearUserNotifications',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearUserNotificationsRequest) =>
      Buffer.from(ClearUserNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      ClearUserNotificationsRequest.decode(value),
    responseSerialize: (value: ClearUserNotificationsResponse) =>
      Buffer.from(ClearUserNotificationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ClearUserNotificationsResponse.decode(value),
  },
  getNotifications: {
    path: '/notification.NotificationService/GetNotifications',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationsRequest) =>
      Buffer.from(GetNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetNotificationsRequest.decode(value),
    responseSerialize: (value: GetNotificationsResponse) =>
      Buffer.from(GetNotificationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetNotificationsResponse.decode(value),
  },
  markAsRead: {
    path: '/notification.NotificationService/MarkAsRead',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkNotificationRequest) =>
      Buffer.from(MarkNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      MarkNotificationRequest.decode(value),
    responseSerialize: (value: NotificationResponse) =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationResponse.decode(value),
  },
  markAllAsRead: {
    path: '/notification.NotificationService/MarkAllAsRead',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkAllNotificationsRequest) =>
      Buffer.from(MarkAllNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      MarkAllNotificationsRequest.decode(value),
    responseSerialize: (value: NotificationResponse) =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NotificationResponse.decode(value),
  },
} as const;

export interface NotificationServiceServer
  extends UntypedServiceImplementation {
  sendOtp: handleUnaryCall<OTPRequest, NotificationResponse>;
  verifyOtp: handleUnaryCall<VerifyOTPRequest, NotificationResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, NotificationResponse>;
  getNotification: handleUnaryCall<
    GetNotificationRequest,
    GetNotificationResponse
  >;
  deleteNotification: handleUnaryCall<
    DeleteNotificationRequest,
    DeleteNotificationResponse
  >;
  clearUserNotifications: handleUnaryCall<
    ClearUserNotificationsRequest,
    ClearUserNotificationsResponse
  >;
  getNotifications: handleUnaryCall<
    GetNotificationsRequest,
    GetNotificationsResponse
  >;
  markAsRead: handleUnaryCall<MarkNotificationRequest, NotificationResponse>;
  markAllAsRead: handleUnaryCall<
    MarkAllNotificationsRequest,
    NotificationResponse
  >;
}

export interface NotificationServiceClient extends Client {
  sendOtp(
    request: OTPRequest,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  sendOtp(
    request: OTPRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  sendOtp(
    request: OTPRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOTPRequest,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOTPRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  verifyOtp(
    request: VerifyOTPRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  getNotification(
    request: GetNotificationRequest,
    callback: (
      error: ServiceError | null,
      response: GetNotificationResponse
    ) => void
  ): ClientUnaryCall;
  getNotification(
    request: GetNotificationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetNotificationResponse
    ) => void
  ): ClientUnaryCall;
  getNotification(
    request: GetNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetNotificationResponse
    ) => void
  ): ClientUnaryCall;
  deleteNotification(
    request: DeleteNotificationRequest,
    callback: (
      error: ServiceError | null,
      response: DeleteNotificationResponse
    ) => void
  ): ClientUnaryCall;
  deleteNotification(
    request: DeleteNotificationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DeleteNotificationResponse
    ) => void
  ): ClientUnaryCall;
  deleteNotification(
    request: DeleteNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DeleteNotificationResponse
    ) => void
  ): ClientUnaryCall;
  clearUserNotifications(
    request: ClearUserNotificationsRequest,
    callback: (
      error: ServiceError | null,
      response: ClearUserNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  clearUserNotifications(
    request: ClearUserNotificationsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ClearUserNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  clearUserNotifications(
    request: ClearUserNotificationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ClearUserNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  getNotifications(
    request: GetNotificationsRequest,
    callback: (
      error: ServiceError | null,
      response: GetNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  getNotifications(
    request: GetNotificationsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  getNotifications(
    request: GetNotificationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetNotificationsResponse
    ) => void
  ): ClientUnaryCall;
  markAsRead(
    request: MarkNotificationRequest,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  markAsRead(
    request: MarkNotificationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  markAsRead(
    request: MarkNotificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  markAllAsRead(
    request: MarkAllNotificationsRequest,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  markAllAsRead(
    request: MarkAllNotificationsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
  markAllAsRead(
    request: MarkAllNotificationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: NotificationResponse
    ) => void
  ): ClientUnaryCall;
}

export const NotificationServiceClient = makeGenericClientConstructor(
  NotificationServiceService,
  'notification.NotificationService'
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>
  ): NotificationServiceClient;
  service: typeof NotificationServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
