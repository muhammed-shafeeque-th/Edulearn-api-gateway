// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.33.2
// source: chat_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';

export const protobufPackage = 'chat_service';

/** Generic empty response */
export interface Empty {}

export interface PaginationRequest {
  /** 1-based */
  page: number;
  /** items per page */
  pageSize: number;
}

export interface PaginationResponse {
  totalItems: number;
  totalPages: number;
}

export interface Conversation {
  id: string;
  studentId: string;
  type: string;
  participants: string[];
  createdAt: number;
  updatedAt: number;
  /** Settings */
  isPinned: boolean;
  isMuted: boolean;
  isArchived: boolean;
  mutedUntil: number;
}

export interface MessageReaction {
  id: string;
  userId: string;
  emoji: string;
  timestamp: number;
}

export interface Message {
  id: string;
  conversationId: string;
  senderId: string;
  content: string;
  status: string;
  createdAt: number;
  updatedAt: number;
  receiverId?: string | undefined;
  type?: string | undefined;
  fileName?: string | undefined;
  fileUrl?: string | undefined;
  fileSize?: string | undefined;
  replayTo?: string | undefined;
  reactions: MessageReaction[];
}

export interface MessageResponse {
  id: string;
  conversationId: string;
  senderId: string;
  content: string;
  status: string;
  createdAt: number;
  updatedAt: number;
  receiverId?: string | undefined;
  type?: string | undefined;
  fileName?: string | undefined;
  fileUrl?: string | undefined;
  fileSize?: string | undefined;
  replayTo?: string | undefined;
  reactions: MessageReaction[];
}

/** A student â†” instructor conversation */
export interface ConversationResponse {
  id: string;
  studentId: string;
  type: string;
  participants: string[];
  createdAt: number;
  updatedAt: number;
  /** Settings */
  isPinned: boolean;
  isMuted: boolean;
  isArchived: boolean;
  mutedUntil: number;
}

export interface CreateConversationRequest {
  /** Domain-specific: 1:1 conversation between these two */
  userId: string;
  otherUserId: string;
  role: string;
  /** Optional for future: explicit type. */
  type: string;
}

export interface CreateConversationResponse {
  conversation: Conversation | undefined;
}

export interface GetConversationRequest {
  conversationId: string;
  userId: string;
}

export interface DeleteConversationRequest {
  conversationId: string;
  userId: string;
}

export interface GetConversationResponse {
  conversation: Conversation | undefined;
}

export interface ListUserConversationsRequest {
  /** The user whose conversations we are listing (student or instructor). */
  userId: string;
  pagination: PaginationRequest | undefined;
}

export interface ListUserConversationsResponse {
  conversations: Conversation[];
  total: number;
}

export interface SendMessageRequest {
  /** optional; generated if empty */
  conversationId: string;
  /** user sending message */
  senderId: string;
  receiverId: string;
  type?: string | undefined;
  metadata: { [key: string]: string };
  /** required for deterministic conv creation */
  studentId: string;
  instructorId: string;
  content: string;
}

export interface SendMessageRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface SendMessageResponse {
  /** stored message */
  message: Message | undefined;
}

/** Paginated chat history request */
export interface GetMessagesRequest {
  conversationId: string;
  userId: string;
  pagination: PaginationRequest | undefined;
}

export interface DeleteMessageRequest {
  conversationId: string;
  messageId: string;
  userId: string;
  forEveryOne: boolean;
}

export interface EditMessageRequest {
  conversationId: string;
  messageId: string;
  userId: string;
  content: string;
}

export interface AddReactionRequest {
  conversationId: string;
  messageId: string;
  userId: string;
  emoji: string;
}

export interface RemoveReactionRequest {
  conversationId: string;
  messageId: string;
  userId: string;
  reactionId: string;
}

export interface GetMessagesResponse {
  messages: Message[];
  total: number;
}

export interface EditMessageResponse {
  messages: Message | undefined;
}

/** Mark message delivered (persistent) */
export interface MarkMessageDeliveredRequest {
  messageId: string;
}

export interface MarkMessagesReadRequest {
  messageId: string;
  userId: string;
  conversationId: string;
}

export interface PinConversationRequest {
  conversationId: string;
  userId: string;
}

export interface UnPinConversationRequest {
  conversationId: string;
  userId: string;
}

export interface MuteConversationRequest {
  conversationId: string;
  userId: string;
  duration?: number | undefined;
}

export interface UnMuteConversationRequest {
  conversationId: string;
  userId: string;
}

export interface ArchiveConversationRequest {
  conversationId: string;
  userId: string;
}

export interface UnArchiveConversationRequest {
  conversationId: string;
  userId: string;
}

/** Search messages inside a conversation or across conversations */
export interface SearchMessagesRequest {
  /** user performing search */
  userId: string;
  /** search text */
  query: string;
  pagination: PaginationRequest | undefined;
}

export interface SearchMessagesResponse {
  results: Message[];
  total: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, pageSize: 0 };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(
    message: PaginationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(
    base?: I
  ): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(
    object: I
  ): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { totalItems: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(
    message: PaginationResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.totalItems !== 0) {
      writer.uint32(8).int32(message.totalItems);
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): PaginationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      totalItems: isSet(object.totalItems)
        ? globalThis.Number(object.totalItems)
        : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(
    base?: I
  ): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(
    object: I
  ): PaginationResponse {
    const message = createBasePaginationResponse();
    message.totalItems = object.totalItems ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseConversation(): Conversation {
  return {
    id: '',
    studentId: '',
    type: '',
    participants: [],
    createdAt: 0,
    updatedAt: 0,
    isPinned: false,
    isMuted: false,
    isArchived: false,
    mutedUntil: 0,
  };
}

export const Conversation: MessageFns<Conversation> = {
  encode(
    message: Conversation,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.studentId !== '') {
      writer.uint32(18).string(message.studentId);
    }
    if (message.type !== '') {
      writer.uint32(50).string(message.type);
    }
    for (const v of message.participants) {
      writer.uint32(26).string(v!);
    }
    if (message.createdAt !== 0) {
      writer.uint32(32).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(40).int64(message.updatedAt);
    }
    if (message.isPinned !== false) {
      writer.uint32(88).bool(message.isPinned);
    }
    if (message.isMuted !== false) {
      writer.uint32(96).bool(message.isMuted);
    }
    if (message.isArchived !== false) {
      writer.uint32(104).bool(message.isArchived);
    }
    if (message.mutedUntil !== 0) {
      writer.uint32(112).int64(message.mutedUntil);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.studentId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participants.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.mutedUntil = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      studentId: isSet(object.studentId)
        ? globalThis.String(object.studentId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.Number(object.updatedAt)
        : 0,
      isPinned: isSet(object.isPinned)
        ? globalThis.Boolean(object.isPinned)
        : false,
      isMuted: isSet(object.isMuted)
        ? globalThis.Boolean(object.isMuted)
        : false,
      isArchived: isSet(object.isArchived)
        ? globalThis.Boolean(object.isArchived)
        : false,
      mutedUntil: isSet(object.mutedUntil)
        ? globalThis.Number(object.mutedUntil)
        : 0,
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.studentId !== '') {
      obj.studentId = message.studentId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.participants?.length) {
      obj.participants = message.participants;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.isPinned !== false) {
      obj.isPinned = message.isPinned;
    }
    if (message.isMuted !== false) {
      obj.isMuted = message.isMuted;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.mutedUntil !== 0) {
      obj.mutedUntil = Math.round(message.mutedUntil);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(
    base?: I
  ): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(
    object: I
  ): Conversation {
    const message = createBaseConversation();
    message.id = object.id ?? '';
    message.studentId = object.studentId ?? '';
    message.type = object.type ?? '';
    message.participants = object.participants?.map(e => e) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.isPinned = object.isPinned ?? false;
    message.isMuted = object.isMuted ?? false;
    message.isArchived = object.isArchived ?? false;
    message.mutedUntil = object.mutedUntil ?? 0;
    return message;
  },
};

function createBaseMessageReaction(): MessageReaction {
  return { id: '', userId: '', emoji: '', timestamp: 0 };
}

export const MessageReaction: MessageFns<MessageReaction> = {
  encode(
    message: MessageReaction,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(26).string(message.id);
    }
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.emoji !== '') {
      writer.uint32(98).string(message.emoji);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.emoji = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : '',
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
    };
  },

  toJSON(message: MessageReaction): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.emoji !== '') {
      obj.emoji = message.emoji;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageReaction>, I>>(
    base?: I
  ): MessageReaction {
    return MessageReaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageReaction>, I>>(
    object: I
  ): MessageReaction {
    const message = createBaseMessageReaction();
    message.id = object.id ?? '';
    message.userId = object.userId ?? '';
    message.emoji = object.emoji ?? '';
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    id: '',
    conversationId: '',
    senderId: '',
    content: '',
    status: '',
    createdAt: 0,
    updatedAt: 0,
    receiverId: undefined,
    type: undefined,
    fileName: undefined,
    fileUrl: undefined,
    fileSize: undefined,
    replayTo: undefined,
    reactions: [],
  };
}

export const Message: MessageFns<Message> = {
  encode(
    message: Message,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.conversationId !== '') {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.senderId !== '') {
      writer.uint32(26).string(message.senderId);
    }
    if (message.content !== '') {
      writer.uint32(42).string(message.content);
    }
    if (message.status !== '') {
      writer.uint32(50).string(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(56).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(64).int64(message.updatedAt);
    }
    if (message.receiverId !== undefined) {
      writer.uint32(34).string(message.receiverId);
    }
    if (message.type !== undefined) {
      writer.uint32(114).string(message.type);
    }
    if (message.fileName !== undefined) {
      writer.uint32(82).string(message.fileName);
    }
    if (message.fileUrl !== undefined) {
      writer.uint32(146).string(message.fileUrl);
    }
    if (message.fileSize !== undefined) {
      writer.uint32(138).string(message.fileSize);
    }
    if (message.replayTo !== undefined) {
      writer.uint32(98).string(message.replayTo);
    }
    for (const v of message.reactions) {
      MessageReaction.encode(v!, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.fileSize = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.replayTo = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.reactions.push(
            MessageReaction.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.Number(object.updatedAt)
        : 0,
      receiverId: isSet(object.receiverId)
        ? globalThis.String(object.receiverId)
        : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : undefined,
      fileUrl: isSet(object.fileUrl)
        ? globalThis.String(object.fileUrl)
        : undefined,
      fileSize: isSet(object.fileSize)
        ? globalThis.String(object.fileSize)
        : undefined,
      replayTo: isSet(object.replayTo)
        ? globalThis.String(object.replayTo)
        : undefined,
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => MessageReaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.receiverId !== undefined) {
      obj.receiverId = message.receiverId;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.fileName !== undefined) {
      obj.fileName = message.fileName;
    }
    if (message.fileUrl !== undefined) {
      obj.fileUrl = message.fileUrl;
    }
    if (message.fileSize !== undefined) {
      obj.fileSize = message.fileSize;
    }
    if (message.replayTo !== undefined) {
      obj.replayTo = message.replayTo;
    }
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map(e => MessageReaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.id = object.id ?? '';
    message.conversationId = object.conversationId ?? '';
    message.senderId = object.senderId ?? '';
    message.content = object.content ?? '';
    message.status = object.status ?? '';
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.receiverId = object.receiverId ?? undefined;
    message.type = object.type ?? undefined;
    message.fileName = object.fileName ?? undefined;
    message.fileUrl = object.fileUrl ?? undefined;
    message.fileSize = object.fileSize ?? undefined;
    message.replayTo = object.replayTo ?? undefined;
    message.reactions =
      object.reactions?.map(e => MessageReaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageResponse(): MessageResponse {
  return {
    id: '',
    conversationId: '',
    senderId: '',
    content: '',
    status: '',
    createdAt: 0,
    updatedAt: 0,
    receiverId: undefined,
    type: undefined,
    fileName: undefined,
    fileUrl: undefined,
    fileSize: undefined,
    replayTo: undefined,
    reactions: [],
  };
}

export const MessageResponse: MessageFns<MessageResponse> = {
  encode(
    message: MessageResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.conversationId !== '') {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.senderId !== '') {
      writer.uint32(26).string(message.senderId);
    }
    if (message.content !== '') {
      writer.uint32(42).string(message.content);
    }
    if (message.status !== '') {
      writer.uint32(50).string(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(56).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(64).int64(message.updatedAt);
    }
    if (message.receiverId !== undefined) {
      writer.uint32(34).string(message.receiverId);
    }
    if (message.type !== undefined) {
      writer.uint32(114).string(message.type);
    }
    if (message.fileName !== undefined) {
      writer.uint32(82).string(message.fileName);
    }
    if (message.fileUrl !== undefined) {
      writer.uint32(146).string(message.fileUrl);
    }
    if (message.fileSize !== undefined) {
      writer.uint32(138).string(message.fileSize);
    }
    if (message.replayTo !== undefined) {
      writer.uint32(98).string(message.replayTo);
    }
    for (const v of message.reactions) {
      MessageReaction.encode(v!, writer.uint32(354).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.fileSize = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.replayTo = reader.string();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.reactions.push(
            MessageReaction.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.Number(object.updatedAt)
        : 0,
      receiverId: isSet(object.receiverId)
        ? globalThis.String(object.receiverId)
        : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : undefined,
      fileUrl: isSet(object.fileUrl)
        ? globalThis.String(object.fileUrl)
        : undefined,
      fileSize: isSet(object.fileSize)
        ? globalThis.String(object.fileSize)
        : undefined,
      replayTo: isSet(object.replayTo)
        ? globalThis.String(object.replayTo)
        : undefined,
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => MessageReaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageResponse): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.receiverId !== undefined) {
      obj.receiverId = message.receiverId;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.fileName !== undefined) {
      obj.fileName = message.fileName;
    }
    if (message.fileUrl !== undefined) {
      obj.fileUrl = message.fileUrl;
    }
    if (message.fileSize !== undefined) {
      obj.fileSize = message.fileSize;
    }
    if (message.replayTo !== undefined) {
      obj.replayTo = message.replayTo;
    }
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map(e => MessageReaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageResponse>, I>>(
    base?: I
  ): MessageResponse {
    return MessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageResponse>, I>>(
    object: I
  ): MessageResponse {
    const message = createBaseMessageResponse();
    message.id = object.id ?? '';
    message.conversationId = object.conversationId ?? '';
    message.senderId = object.senderId ?? '';
    message.content = object.content ?? '';
    message.status = object.status ?? '';
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.receiverId = object.receiverId ?? undefined;
    message.type = object.type ?? undefined;
    message.fileName = object.fileName ?? undefined;
    message.fileUrl = object.fileUrl ?? undefined;
    message.fileSize = object.fileSize ?? undefined;
    message.replayTo = object.replayTo ?? undefined;
    message.reactions =
      object.reactions?.map(e => MessageReaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversationResponse(): ConversationResponse {
  return {
    id: '',
    studentId: '',
    type: '',
    participants: [],
    createdAt: 0,
    updatedAt: 0,
    isPinned: false,
    isMuted: false,
    isArchived: false,
    mutedUntil: 0,
  };
}

export const ConversationResponse: MessageFns<ConversationResponse> = {
  encode(
    message: ConversationResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.studentId !== '') {
      writer.uint32(18).string(message.studentId);
    }
    if (message.type !== '') {
      writer.uint32(50).string(message.type);
    }
    for (const v of message.participants) {
      writer.uint32(26).string(v!);
    }
    if (message.createdAt !== 0) {
      writer.uint32(32).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(40).int64(message.updatedAt);
    }
    if (message.isPinned !== false) {
      writer.uint32(88).bool(message.isPinned);
    }
    if (message.isMuted !== false) {
      writer.uint32(96).bool(message.isMuted);
    }
    if (message.isArchived !== false) {
      writer.uint32(104).bool(message.isArchived);
    }
    if (message.mutedUntil !== 0) {
      writer.uint32(112).int64(message.mutedUntil);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ConversationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.studentId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participants.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.mutedUntil = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      studentId: isSet(object.studentId)
        ? globalThis.String(object.studentId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.Number(object.updatedAt)
        : 0,
      isPinned: isSet(object.isPinned)
        ? globalThis.Boolean(object.isPinned)
        : false,
      isMuted: isSet(object.isMuted)
        ? globalThis.Boolean(object.isMuted)
        : false,
      isArchived: isSet(object.isArchived)
        ? globalThis.Boolean(object.isArchived)
        : false,
      mutedUntil: isSet(object.mutedUntil)
        ? globalThis.Number(object.mutedUntil)
        : 0,
    };
  },

  toJSON(message: ConversationResponse): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.studentId !== '') {
      obj.studentId = message.studentId;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.participants?.length) {
      obj.participants = message.participants;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.isPinned !== false) {
      obj.isPinned = message.isPinned;
    }
    if (message.isMuted !== false) {
      obj.isMuted = message.isMuted;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    if (message.mutedUntil !== 0) {
      obj.mutedUntil = Math.round(message.mutedUntil);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationResponse>, I>>(
    base?: I
  ): ConversationResponse {
    return ConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationResponse>, I>>(
    object: I
  ): ConversationResponse {
    const message = createBaseConversationResponse();
    message.id = object.id ?? '';
    message.studentId = object.studentId ?? '';
    message.type = object.type ?? '';
    message.participants = object.participants?.map(e => e) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.isPinned = object.isPinned ?? false;
    message.isMuted = object.isMuted ?? false;
    message.isArchived = object.isArchived ?? false;
    message.mutedUntil = object.mutedUntil ?? 0;
    return message;
  },
};

function createBaseCreateConversationRequest(): CreateConversationRequest {
  return { userId: '', otherUserId: '', role: '', type: '' };
}

export const CreateConversationRequest: MessageFns<CreateConversationRequest> =
  {
    encode(
      message: CreateConversationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== '') {
        writer.uint32(10).string(message.userId);
      }
      if (message.otherUserId !== '') {
        writer.uint32(18).string(message.otherUserId);
      }
      if (message.role !== '') {
        writer.uint32(34).string(message.role);
      }
      if (message.type !== '') {
        writer.uint32(26).string(message.type);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateConversationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateConversationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.otherUserId = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.role = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.type = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateConversationRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
        otherUserId: isSet(object.otherUserId)
          ? globalThis.String(object.otherUserId)
          : '',
        role: isSet(object.role) ? globalThis.String(object.role) : '',
        type: isSet(object.type) ? globalThis.String(object.type) : '',
      };
    },

    toJSON(message: CreateConversationRequest): unknown {
      const obj: any = {};
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      if (message.otherUserId !== '') {
        obj.otherUserId = message.otherUserId;
      }
      if (message.role !== '') {
        obj.role = message.role;
      }
      if (message.type !== '') {
        obj.type = message.type;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(
      base?: I
    ): CreateConversationRequest {
      return CreateConversationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(
      object: I
    ): CreateConversationRequest {
      const message = createBaseCreateConversationRequest();
      message.userId = object.userId ?? '';
      message.otherUserId = object.otherUserId ?? '';
      message.role = object.role ?? '';
      message.type = object.type ?? '';
      return message;
    },
  };

function createBaseCreateConversationResponse(): CreateConversationResponse {
  return { conversation: undefined };
}

export const CreateConversationResponse: MessageFns<CreateConversationResponse> =
  {
    encode(
      message: CreateConversationResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.conversation !== undefined) {
        Conversation.encode(
          message.conversation,
          writer.uint32(10).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CreateConversationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateConversationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversation = Conversation.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateConversationResponse {
      return {
        conversation: isSet(object.conversation)
          ? Conversation.fromJSON(object.conversation)
          : undefined,
      };
    },

    toJSON(message: CreateConversationResponse): unknown {
      const obj: any = {};
      if (message.conversation !== undefined) {
        obj.conversation = Conversation.toJSON(message.conversation);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(
      base?: I
    ): CreateConversationResponse {
      return CreateConversationResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(
      object: I
    ): CreateConversationResponse {
      const message = createBaseCreateConversationResponse();
      message.conversation =
        object.conversation !== undefined && object.conversation !== null
          ? Conversation.fromPartial(object.conversation)
          : undefined;
      return message;
    },
  };

function createBaseGetConversationRequest(): GetConversationRequest {
  return { conversationId: '', userId: '' };
}

export const GetConversationRequest: MessageFns<GetConversationRequest> = {
  encode(
    message: GetConversationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: GetConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationRequest>, I>>(
    base?: I
  ): GetConversationRequest {
    return GetConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationRequest>, I>>(
    object: I
  ): GetConversationRequest {
    const message = createBaseGetConversationRequest();
    message.conversationId = object.conversationId ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseDeleteConversationRequest(): DeleteConversationRequest {
  return { conversationId: '', userId: '' };
}

export const DeleteConversationRequest: MessageFns<DeleteConversationRequest> =
  {
    encode(
      message: DeleteConversationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.conversationId !== '') {
        writer.uint32(10).string(message.conversationId);
      }
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): DeleteConversationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDeleteConversationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversationId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DeleteConversationRequest {
      return {
        conversationId: isSet(object.conversationId)
          ? globalThis.String(object.conversationId)
          : '',
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: DeleteConversationRequest): unknown {
      const obj: any = {};
      if (message.conversationId !== '') {
        obj.conversationId = message.conversationId;
      }
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<DeleteConversationRequest>, I>>(
      base?: I
    ): DeleteConversationRequest {
      return DeleteConversationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DeleteConversationRequest>, I>>(
      object: I
    ): DeleteConversationRequest {
      const message = createBaseDeleteConversationRequest();
      message.conversationId = object.conversationId ?? '';
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseGetConversationResponse(): GetConversationResponse {
  return { conversation: undefined };
}

export const GetConversationResponse: MessageFns<GetConversationResponse> = {
  encode(
    message: GetConversationResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversation !== undefined) {
      Conversation.encode(
        message.conversation,
        writer.uint32(10).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetConversationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationResponse {
    return {
      conversation: isSet(object.conversation)
        ? Conversation.fromJSON(object.conversation)
        : undefined,
    };
  },

  toJSON(message: GetConversationResponse): unknown {
    const obj: any = {};
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationResponse>, I>>(
    base?: I
  ): GetConversationResponse {
    return GetConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationResponse>, I>>(
    object: I
  ): GetConversationResponse {
    const message = createBaseGetConversationResponse();
    message.conversation =
      object.conversation !== undefined && object.conversation !== null
        ? Conversation.fromPartial(object.conversation)
        : undefined;
    return message;
  },
};

function createBaseListUserConversationsRequest(): ListUserConversationsRequest {
  return { userId: '', pagination: undefined };
}

export const ListUserConversationsRequest: MessageFns<ListUserConversationsRequest> =
  {
    encode(
      message: ListUserConversationsRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.userId !== '') {
        writer.uint32(10).string(message.userId);
      }
      if (message.pagination !== undefined) {
        PaginationRequest.encode(
          message.pagination,
          writer.uint32(26).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): ListUserConversationsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseListUserConversationsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.pagination = PaginationRequest.decode(
              reader,
              reader.uint32()
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ListUserConversationsRequest {
      return {
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
        pagination: isSet(object.pagination)
          ? PaginationRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: ListUserConversationsRequest): unknown {
      const obj: any = {};
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      if (message.pagination !== undefined) {
        obj.pagination = PaginationRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ListUserConversationsRequest>, I>>(
      base?: I
    ): ListUserConversationsRequest {
      return ListUserConversationsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ListUserConversationsRequest>, I>>(
      object: I
    ): ListUserConversationsRequest {
      const message = createBaseListUserConversationsRequest();
      message.userId = object.userId ?? '';
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PaginationRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseListUserConversationsResponse(): ListUserConversationsResponse {
  return { conversations: [], total: 0 };
}

export const ListUserConversationsResponse: MessageFns<ListUserConversationsResponse> =
  {
    encode(
      message: ListUserConversationsResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      for (const v of message.conversations) {
        Conversation.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.total !== 0) {
        writer.uint32(16).int32(message.total);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): ListUserConversationsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseListUserConversationsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversations.push(
              Conversation.decode(reader, reader.uint32())
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.total = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ListUserConversationsResponse {
      return {
        conversations: globalThis.Array.isArray(object?.conversations)
          ? object.conversations.map((e: any) => Conversation.fromJSON(e))
          : [],
        total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      };
    },

    toJSON(message: ListUserConversationsResponse): unknown {
      const obj: any = {};
      if (message.conversations?.length) {
        obj.conversations = message.conversations.map(e =>
          Conversation.toJSON(e)
        );
      }
      if (message.total !== 0) {
        obj.total = Math.round(message.total);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ListUserConversationsResponse>, I>>(
      base?: I
    ): ListUserConversationsResponse {
      return ListUserConversationsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ListUserConversationsResponse>, I>>(
      object: I
    ): ListUserConversationsResponse {
      const message = createBaseListUserConversationsResponse();
      message.conversations =
        object.conversations?.map(e => Conversation.fromPartial(e)) || [];
      message.total = object.total ?? 0;
      return message;
    },
  };

function createBaseSendMessageRequest(): SendMessageRequest {
  return {
    conversationId: '',
    senderId: '',
    receiverId: '',
    type: undefined,
    metadata: {},
    studentId: '',
    instructorId: '',
    content: '',
  };
}

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  encode(
    message: SendMessageRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.senderId !== '') {
      writer.uint32(18).string(message.senderId);
    }
    if (message.receiverId !== '') {
      writer.uint32(26).string(message.receiverId);
    }
    if (message.type !== undefined) {
      writer.uint32(74).string(message.type);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SendMessageRequest_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(66).fork()
      ).join();
    });
    if (message.studentId !== '') {
      writer.uint32(34).string(message.studentId);
    }
    if (message.instructorId !== '') {
      writer.uint32(42).string(message.instructorId);
    }
    if (message.content !== '') {
      writer.uint32(50).string(message.content);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SendMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiverId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = SendMessageRequest_MetadataEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.studentId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instructorId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      senderId: isSet(object.senderId)
        ? globalThis.String(object.senderId)
        : '',
      receiverId: isSet(object.receiverId)
        ? globalThis.String(object.receiverId)
        : '',
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {}
          )
        : {},
      studentId: isSet(object.studentId)
        ? globalThis.String(object.studentId)
        : '',
      instructorId: isSet(object.instructorId)
        ? globalThis.String(object.instructorId)
        : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.senderId !== '') {
      obj.senderId = message.senderId;
    }
    if (message.receiverId !== '') {
      obj.receiverId = message.receiverId;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.studentId !== '') {
      obj.studentId = message.studentId;
    }
    if (message.instructorId !== '') {
      obj.instructorId = message.instructorId;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    base?: I
  ): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(
    object: I
  ): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.conversationId = object.conversationId ?? '';
    message.senderId = object.senderId ?? '';
    message.receiverId = object.receiverId ?? '';
    message.type = object.type ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.studentId = object.studentId ?? '';
    message.instructorId = object.instructorId ?? '';
    message.content = object.content ?? '';
    return message;
  },
};

function createBaseSendMessageRequest_MetadataEntry(): SendMessageRequest_MetadataEntry {
  return { key: '', value: '' };
}

export const SendMessageRequest_MetadataEntry: MessageFns<SendMessageRequest_MetadataEntry> =
  {
    encode(
      message: SendMessageRequest_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== '') {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): SendMessageRequest_MetadataEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSendMessageRequest_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SendMessageRequest_MetadataEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : '',
        value: isSet(object.value) ? globalThis.String(object.value) : '',
      };
    },

    toJSON(message: SendMessageRequest_MetadataEntry): unknown {
      const obj: any = {};
      if (message.key !== '') {
        obj.key = message.key;
      }
      if (message.value !== '') {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SendMessageRequest_MetadataEntry>, I>>(
      base?: I
    ): SendMessageRequest_MetadataEntry {
      return SendMessageRequest_MetadataEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<SendMessageRequest_MetadataEntry>, I>,
    >(object: I): SendMessageRequest_MetadataEntry {
      const message = createBaseSendMessageRequest_MetadataEntry();
      message.key = object.key ?? '';
      message.value = object.value ?? '';
      return message;
    },
  };

function createBaseSendMessageResponse(): SendMessageResponse {
  return { message: undefined };
}

export const SendMessageResponse: MessageFns<SendMessageResponse> = {
  encode(
    message: SendMessageResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SendMessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResponse {
    return {
      message: isSet(object.message)
        ? Message.fromJSON(object.message)
        : undefined,
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(
    base?: I
  ): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(
    object: I
  ): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    message.message =
      object.message !== undefined && object.message !== null
        ? Message.fromPartial(object.message)
        : undefined;
    return message;
  },
};

function createBaseGetMessagesRequest(): GetMessagesRequest {
  return { conversationId: '', userId: '', pagination: undefined };
}

export const GetMessagesRequest: MessageFns<GetMessagesRequest> = {
  encode(
    message: GetMessagesRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.userId !== '') {
      writer.uint32(26).string(message.userId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(
        message.pagination,
        writer.uint32(18).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetMessagesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      pagination: isSet(object.pagination)
        ? PaginationRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: GetMessagesRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(
    base?: I
  ): GetMessagesRequest {
    return GetMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(
    object: I
  ): GetMessagesRequest {
    const message = createBaseGetMessagesRequest();
    message.conversationId = object.conversationId ?? '';
    message.userId = object.userId ?? '';
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseDeleteMessageRequest(): DeleteMessageRequest {
  return { conversationId: '', messageId: '', userId: '', forEveryOne: false };
}

export const DeleteMessageRequest: MessageFns<DeleteMessageRequest> = {
  encode(
    message: DeleteMessageRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== '') {
      writer.uint32(18).string(message.messageId);
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.forEveryOne !== false) {
      writer.uint32(24).bool(message.forEveryOne);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): DeleteMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.forEveryOne = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      forEveryOne: isSet(object.forEveryOne)
        ? globalThis.Boolean(object.forEveryOne)
        : false,
    };
  },

  toJSON(message: DeleteMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.forEveryOne !== false) {
      obj.forEveryOne = message.forEveryOne;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(
    base?: I
  ): DeleteMessageRequest {
    return DeleteMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(
    object: I
  ): DeleteMessageRequest {
    const message = createBaseDeleteMessageRequest();
    message.conversationId = object.conversationId ?? '';
    message.messageId = object.messageId ?? '';
    message.userId = object.userId ?? '';
    message.forEveryOne = object.forEveryOne ?? false;
    return message;
  },
};

function createBaseEditMessageRequest(): EditMessageRequest {
  return { conversationId: '', messageId: '', userId: '', content: '' };
}

export const EditMessageRequest: MessageFns<EditMessageRequest> = {
  encode(
    message: EditMessageRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== '') {
      writer.uint32(18).string(message.messageId);
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.content !== '') {
      writer.uint32(26).string(message.content);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EditMessageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditMessageRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
    };
  },

  toJSON(message: EditMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditMessageRequest>, I>>(
    base?: I
  ): EditMessageRequest {
    return EditMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditMessageRequest>, I>>(
    object: I
  ): EditMessageRequest {
    const message = createBaseEditMessageRequest();
    message.conversationId = object.conversationId ?? '';
    message.messageId = object.messageId ?? '';
    message.userId = object.userId ?? '';
    message.content = object.content ?? '';
    return message;
  },
};

function createBaseAddReactionRequest(): AddReactionRequest {
  return { conversationId: '', messageId: '', userId: '', emoji: '' };
}

export const AddReactionRequest: MessageFns<AddReactionRequest> = {
  encode(
    message: AddReactionRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== '') {
      writer.uint32(18).string(message.messageId);
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.emoji !== '') {
      writer.uint32(26).string(message.emoji);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): AddReactionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emoji = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddReactionRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : '',
    };
  },

  toJSON(message: AddReactionRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.emoji !== '') {
      obj.emoji = message.emoji;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddReactionRequest>, I>>(
    base?: I
  ): AddReactionRequest {
    return AddReactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddReactionRequest>, I>>(
    object: I
  ): AddReactionRequest {
    const message = createBaseAddReactionRequest();
    message.conversationId = object.conversationId ?? '';
    message.messageId = object.messageId ?? '';
    message.userId = object.userId ?? '';
    message.emoji = object.emoji ?? '';
    return message;
  },
};

function createBaseRemoveReactionRequest(): RemoveReactionRequest {
  return { conversationId: '', messageId: '', userId: '', reactionId: '' };
}

export const RemoveReactionRequest: MessageFns<RemoveReactionRequest> = {
  encode(
    message: RemoveReactionRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== '') {
      writer.uint32(18).string(message.messageId);
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.reactionId !== '') {
      writer.uint32(26).string(message.reactionId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): RemoveReactionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveReactionRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      reactionId: isSet(object.reactionId)
        ? globalThis.String(object.reactionId)
        : '',
    };
  },

  toJSON(message: RemoveReactionRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.reactionId !== '') {
      obj.reactionId = message.reactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveReactionRequest>, I>>(
    base?: I
  ): RemoveReactionRequest {
    return RemoveReactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveReactionRequest>, I>>(
    object: I
  ): RemoveReactionRequest {
    const message = createBaseRemoveReactionRequest();
    message.conversationId = object.conversationId ?? '';
    message.messageId = object.messageId ?? '';
    message.userId = object.userId ?? '';
    message.reactionId = object.reactionId ?? '';
    return message;
  },
};

function createBaseGetMessagesResponse(): GetMessagesResponse {
  return { messages: [], total: 0 };
}

export const GetMessagesResponse: MessageFns<GetMessagesResponse> = {
  encode(
    message: GetMessagesResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetMessagesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => Message.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: GetMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => Message.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(
    base?: I
  ): GetMessagesResponse {
    return GetMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(
    object: I
  ): GetMessagesResponse {
    const message = createBaseGetMessagesResponse();
    message.messages = object.messages?.map(e => Message.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseEditMessageResponse(): EditMessageResponse {
  return { messages: undefined };
}

export const EditMessageResponse: MessageFns<EditMessageResponse> = {
  encode(
    message: EditMessageResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.messages !== undefined) {
      Message.encode(message.messages, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): EditMessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages = Message.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditMessageResponse {
    return {
      messages: isSet(object.messages)
        ? Message.fromJSON(object.messages)
        : undefined,
    };
  },

  toJSON(message: EditMessageResponse): unknown {
    const obj: any = {};
    if (message.messages !== undefined) {
      obj.messages = Message.toJSON(message.messages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditMessageResponse>, I>>(
    base?: I
  ): EditMessageResponse {
    return EditMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditMessageResponse>, I>>(
    object: I
  ): EditMessageResponse {
    const message = createBaseEditMessageResponse();
    message.messages =
      object.messages !== undefined && object.messages !== null
        ? Message.fromPartial(object.messages)
        : undefined;
    return message;
  },
};

function createBaseMarkMessageDeliveredRequest(): MarkMessageDeliveredRequest {
  return { messageId: '' };
}

export const MarkMessageDeliveredRequest: MessageFns<MarkMessageDeliveredRequest> =
  {
    encode(
      message: MarkMessageDeliveredRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.messageId !== '') {
        writer.uint32(10).string(message.messageId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): MarkMessageDeliveredRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMarkMessageDeliveredRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.messageId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MarkMessageDeliveredRequest {
      return {
        messageId: isSet(object.messageId)
          ? globalThis.String(object.messageId)
          : '',
      };
    },

    toJSON(message: MarkMessageDeliveredRequest): unknown {
      const obj: any = {};
      if (message.messageId !== '') {
        obj.messageId = message.messageId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MarkMessageDeliveredRequest>, I>>(
      base?: I
    ): MarkMessageDeliveredRequest {
      return MarkMessageDeliveredRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MarkMessageDeliveredRequest>, I>>(
      object: I
    ): MarkMessageDeliveredRequest {
      const message = createBaseMarkMessageDeliveredRequest();
      message.messageId = object.messageId ?? '';
      return message;
    },
  };

function createBaseMarkMessagesReadRequest(): MarkMessagesReadRequest {
  return { messageId: '', userId: '', conversationId: '' };
}

export const MarkMessagesReadRequest: MessageFns<MarkMessagesReadRequest> = {
  encode(
    message: MarkMessagesReadRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.messageId !== '') {
      writer.uint32(10).string(message.messageId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.conversationId !== '') {
      writer.uint32(26).string(message.conversationId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): MarkMessagesReadRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkMessagesReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkMessagesReadRequest {
    return {
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
    };
  },

  toJSON(message: MarkMessagesReadRequest): unknown {
    const obj: any = {};
    if (message.messageId !== '') {
      obj.messageId = message.messageId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkMessagesReadRequest>, I>>(
    base?: I
  ): MarkMessagesReadRequest {
    return MarkMessagesReadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkMessagesReadRequest>, I>>(
    object: I
  ): MarkMessagesReadRequest {
    const message = createBaseMarkMessagesReadRequest();
    message.messageId = object.messageId ?? '';
    message.userId = object.userId ?? '';
    message.conversationId = object.conversationId ?? '';
    return message;
  },
};

function createBasePinConversationRequest(): PinConversationRequest {
  return { conversationId: '', userId: '' };
}

export const PinConversationRequest: MessageFns<PinConversationRequest> = {
  encode(
    message: PinConversationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): PinConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinConversationRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: PinConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinConversationRequest>, I>>(
    base?: I
  ): PinConversationRequest {
    return PinConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinConversationRequest>, I>>(
    object: I
  ): PinConversationRequest {
    const message = createBasePinConversationRequest();
    message.conversationId = object.conversationId ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseUnPinConversationRequest(): UnPinConversationRequest {
  return { conversationId: '', userId: '' };
}

export const UnPinConversationRequest: MessageFns<UnPinConversationRequest> = {
  encode(
    message: UnPinConversationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): UnPinConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnPinConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnPinConversationRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: UnPinConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnPinConversationRequest>, I>>(
    base?: I
  ): UnPinConversationRequest {
    return UnPinConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnPinConversationRequest>, I>>(
    object: I
  ): UnPinConversationRequest {
    const message = createBaseUnPinConversationRequest();
    message.conversationId = object.conversationId ?? '';
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseMuteConversationRequest(): MuteConversationRequest {
  return { conversationId: '', userId: '', duration: undefined };
}

export const MuteConversationRequest: MessageFns<MuteConversationRequest> = {
  encode(
    message: MuteConversationRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.conversationId !== '') {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.duration !== undefined) {
      writer.uint32(24).int64(message.duration);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): MuteConversationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteConversationRequest {
    return {
      conversationId: isSet(object.conversationId)
        ? globalThis.String(object.conversationId)
        : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      duration: isSet(object.duration)
        ? globalThis.Number(object.duration)
        : undefined,
    };
  },

  toJSON(message: MuteConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== '') {
      obj.conversationId = message.conversationId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.duration !== undefined) {
      obj.duration = Math.round(message.duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteConversationRequest>, I>>(
    base?: I
  ): MuteConversationRequest {
    return MuteConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteConversationRequest>, I>>(
    object: I
  ): MuteConversationRequest {
    const message = createBaseMuteConversationRequest();
    message.conversationId = object.conversationId ?? '';
    message.userId = object.userId ?? '';
    message.duration = object.duration ?? undefined;
    return message;
  },
};

function createBaseUnMuteConversationRequest(): UnMuteConversationRequest {
  return { conversationId: '', userId: '' };
}

export const UnMuteConversationRequest: MessageFns<UnMuteConversationRequest> =
  {
    encode(
      message: UnMuteConversationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.conversationId !== '') {
        writer.uint32(10).string(message.conversationId);
      }
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): UnMuteConversationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUnMuteConversationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversationId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UnMuteConversationRequest {
      return {
        conversationId: isSet(object.conversationId)
          ? globalThis.String(object.conversationId)
          : '',
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: UnMuteConversationRequest): unknown {
      const obj: any = {};
      if (message.conversationId !== '') {
        obj.conversationId = message.conversationId;
      }
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<UnMuteConversationRequest>, I>>(
      base?: I
    ): UnMuteConversationRequest {
      return UnMuteConversationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<UnMuteConversationRequest>, I>>(
      object: I
    ): UnMuteConversationRequest {
      const message = createBaseUnMuteConversationRequest();
      message.conversationId = object.conversationId ?? '';
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseArchiveConversationRequest(): ArchiveConversationRequest {
  return { conversationId: '', userId: '' };
}

export const ArchiveConversationRequest: MessageFns<ArchiveConversationRequest> =
  {
    encode(
      message: ArchiveConversationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.conversationId !== '') {
        writer.uint32(10).string(message.conversationId);
      }
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): ArchiveConversationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseArchiveConversationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversationId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ArchiveConversationRequest {
      return {
        conversationId: isSet(object.conversationId)
          ? globalThis.String(object.conversationId)
          : '',
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: ArchiveConversationRequest): unknown {
      const obj: any = {};
      if (message.conversationId !== '') {
        obj.conversationId = message.conversationId;
      }
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ArchiveConversationRequest>, I>>(
      base?: I
    ): ArchiveConversationRequest {
      return ArchiveConversationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ArchiveConversationRequest>, I>>(
      object: I
    ): ArchiveConversationRequest {
      const message = createBaseArchiveConversationRequest();
      message.conversationId = object.conversationId ?? '';
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseUnArchiveConversationRequest(): UnArchiveConversationRequest {
  return { conversationId: '', userId: '' };
}

export const UnArchiveConversationRequest: MessageFns<UnArchiveConversationRequest> =
  {
    encode(
      message: UnArchiveConversationRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.conversationId !== '') {
        writer.uint32(10).string(message.conversationId);
      }
      if (message.userId !== '') {
        writer.uint32(18).string(message.userId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): UnArchiveConversationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUnArchiveConversationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversationId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UnArchiveConversationRequest {
      return {
        conversationId: isSet(object.conversationId)
          ? globalThis.String(object.conversationId)
          : '',
        userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      };
    },

    toJSON(message: UnArchiveConversationRequest): unknown {
      const obj: any = {};
      if (message.conversationId !== '') {
        obj.conversationId = message.conversationId;
      }
      if (message.userId !== '') {
        obj.userId = message.userId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<UnArchiveConversationRequest>, I>>(
      base?: I
    ): UnArchiveConversationRequest {
      return UnArchiveConversationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<UnArchiveConversationRequest>, I>>(
      object: I
    ): UnArchiveConversationRequest {
      const message = createBaseUnArchiveConversationRequest();
      message.conversationId = object.conversationId ?? '';
      message.userId = object.userId ?? '';
      return message;
    },
  };

function createBaseSearchMessagesRequest(): SearchMessagesRequest {
  return { userId: '', query: '', pagination: undefined };
}

export const SearchMessagesRequest: MessageFns<SearchMessagesRequest> = {
  encode(
    message: SearchMessagesRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.query !== '') {
      writer.uint32(18).string(message.query);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(
        message.pagination,
        writer.uint32(26).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SearchMessagesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationRequest.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchMessagesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      query: isSet(object.query) ? globalThis.String(object.query) : '',
      pagination: isSet(object.pagination)
        ? PaginationRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: SearchMessagesRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.query !== '') {
      obj.query = message.query;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchMessagesRequest>, I>>(
    base?: I
  ): SearchMessagesRequest {
    return SearchMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchMessagesRequest>, I>>(
    object: I
  ): SearchMessagesRequest {
    const message = createBaseSearchMessagesRequest();
    message.userId = object.userId ?? '';
    message.query = object.query ?? '';
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseSearchMessagesResponse(): SearchMessagesResponse {
  return { results: [], total: 0 };
}

export const SearchMessagesResponse: MessageFns<SearchMessagesResponse> = {
  encode(
    message: SearchMessagesResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.results) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SearchMessagesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchMessagesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => Message.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: SearchMessagesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map(e => Message.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchMessagesResponse>, I>>(
    base?: I
  ): SearchMessagesResponse {
    return SearchMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchMessagesResponse>, I>>(
    object: I
  ): SearchMessagesResponse {
    const message = createBaseSearchMessagesResponse();
    message.results = object.results?.map(e => Message.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

/**
 * -------------------------
 * Conversations
 * -------------------------
 */
export type ChatServiceService = typeof ChatServiceService;
export const ChatServiceService = {
  /** Get existing or create new one-to-one conversation (student <-> instructor). */
  createConversation: {
    path: '/chat_service.ChatService/CreateConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateConversationRequest) =>
      Buffer.from(CreateConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      CreateConversationRequest.decode(value),
    responseSerialize: (value: CreateConversationResponse) =>
      Buffer.from(CreateConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CreateConversationResponse.decode(value),
  },
  /** Get a single conversation by id. */
  getConversation: {
    path: '/chat_service.ChatService/GetConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConversationRequest) =>
      Buffer.from(GetConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConversationRequest.decode(value),
    responseSerialize: (value: GetConversationResponse) =>
      Buffer.from(GetConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetConversationResponse.decode(value),
  },
  deleteConversation: {
    path: '/chat_service.ChatService/DeleteConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConversationRequest) =>
      Buffer.from(DeleteConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      DeleteConversationRequest.decode(value),
    responseSerialize: (value: Empty) =>
      Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  /** List all conversations for a user (student or instructor). */
  listUserConversations: {
    path: '/chat_service.ChatService/ListUserConversations',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUserConversationsRequest) =>
      Buffer.from(ListUserConversationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      ListUserConversationsRequest.decode(value),
    responseSerialize: (value: ListUserConversationsResponse) =>
      Buffer.from(ListUserConversationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ListUserConversationsResponse.decode(value),
  },
  pinConversation: {
    path: '/chat_service.ChatService/PinConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PinConversationRequest) =>
      Buffer.from(PinConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PinConversationRequest.decode(value),
    responseSerialize: (value: ConversationResponse) =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
  unPinConversation: {
    path: '/chat_service.ChatService/UnPinConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnPinConversationRequest) =>
      Buffer.from(UnPinConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      UnPinConversationRequest.decode(value),
    responseSerialize: (value: ConversationResponse) =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
  archiveConversation: {
    path: '/chat_service.ChatService/ArchiveConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ArchiveConversationRequest) =>
      Buffer.from(ArchiveConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      ArchiveConversationRequest.decode(value),
    responseSerialize: (value: ConversationResponse) =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
  unArchiveConversation: {
    path: '/chat_service.ChatService/UnArchiveConversation',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnArchiveConversationRequest) =>
      Buffer.from(UnArchiveConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      UnArchiveConversationRequest.decode(value),
    responseSerialize: (value: ConversationResponse) =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
  sendMessage: {
    path: '/chat_service.ChatService/SendMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) =>
      Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) =>
      Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
  /** Fetch paginated messages for a conversation (chat history). */
  getMessages: {
    path: '/chat_service.ChatService/GetMessages',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMessagesRequest) =>
      Buffer.from(GetMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMessagesRequest.decode(value),
    responseSerialize: (value: GetMessagesResponse) =>
      Buffer.from(GetMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMessagesResponse.decode(value),
  },
  editMessage: {
    path: '/chat_service.ChatService/EditMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EditMessageRequest) =>
      Buffer.from(EditMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EditMessageRequest.decode(value),
    responseSerialize: (value: EditMessageResponse) =>
      Buffer.from(EditMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EditMessageResponse.decode(value),
  },
  deleteMessage: {
    path: '/chat_service.ChatService/DeleteMessage',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMessageRequest) =>
      Buffer.from(DeleteMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteMessageRequest.decode(value),
    responseSerialize: (value: Empty) =>
      Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  addReaction: {
    path: '/chat_service.ChatService/AddReaction',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddReactionRequest) =>
      Buffer.from(AddReactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddReactionRequest.decode(value),
    responseSerialize: (value: MessageResponse) =>
      Buffer.from(MessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MessageResponse.decode(value),
  },
  removeReaction: {
    path: '/chat_service.ChatService/RemoveReaction',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveReactionRequest) =>
      Buffer.from(RemoveReactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveReactionRequest.decode(value),
    responseSerialize: (value: MessageResponse) =>
      Buffer.from(MessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MessageResponse.decode(value),
  },
  /** Update seen state when user actually reads the message. */
  markMessagesRead: {
    path: '/chat_service.ChatService/MarkMessagesRead',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkMessagesReadRequest) =>
      Buffer.from(MarkMessagesReadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      MarkMessagesReadRequest.decode(value),
    responseSerialize: (value: ConversationResponse) =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
} as const;

export interface ChatServiceServer extends UntypedServiceImplementation {
  /** Get existing or create new one-to-one conversation (student <-> instructor). */
  createConversation: handleUnaryCall<
    CreateConversationRequest,
    CreateConversationResponse
  >;
  /** Get a single conversation by id. */
  getConversation: handleUnaryCall<
    GetConversationRequest,
    GetConversationResponse
  >;
  deleteConversation: handleUnaryCall<DeleteConversationRequest, Empty>;
  /** List all conversations for a user (student or instructor). */
  listUserConversations: handleUnaryCall<
    ListUserConversationsRequest,
    ListUserConversationsResponse
  >;
  pinConversation: handleUnaryCall<
    PinConversationRequest,
    ConversationResponse
  >;
  unPinConversation: handleUnaryCall<
    UnPinConversationRequest,
    ConversationResponse
  >;
  archiveConversation: handleUnaryCall<
    ArchiveConversationRequest,
    ConversationResponse
  >;
  unArchiveConversation: handleUnaryCall<
    UnArchiveConversationRequest,
    ConversationResponse
  >;
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
  /** Fetch paginated messages for a conversation (chat history). */
  getMessages: handleUnaryCall<GetMessagesRequest, GetMessagesResponse>;
  editMessage: handleUnaryCall<EditMessageRequest, EditMessageResponse>;
  deleteMessage: handleUnaryCall<DeleteMessageRequest, Empty>;
  addReaction: handleUnaryCall<AddReactionRequest, MessageResponse>;
  removeReaction: handleUnaryCall<RemoveReactionRequest, MessageResponse>;
  /** Update seen state when user actually reads the message. */
  markMessagesRead: handleUnaryCall<
    MarkMessagesReadRequest,
    ConversationResponse
  >;
}

export interface ChatServiceClient extends Client {
  /** Get existing or create new one-to-one conversation (student <-> instructor). */
  createConversation(
    request: CreateConversationRequest,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse
    ) => void
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse
    ) => void
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: CreateConversationResponse
    ) => void
  ): ClientUnaryCall;
  /** Get a single conversation by id. */
  getConversation(
    request: GetConversationRequest,
    callback: (
      error: ServiceError | null,
      response: GetConversationResponse
    ) => void
  ): ClientUnaryCall;
  getConversation(
    request: GetConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetConversationResponse
    ) => void
  ): ClientUnaryCall;
  getConversation(
    request: GetConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetConversationResponse
    ) => void
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  /** List all conversations for a user (student or instructor). */
  listUserConversations(
    request: ListUserConversationsRequest,
    callback: (
      error: ServiceError | null,
      response: ListUserConversationsResponse
    ) => void
  ): ClientUnaryCall;
  listUserConversations(
    request: ListUserConversationsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ListUserConversationsResponse
    ) => void
  ): ClientUnaryCall;
  listUserConversations(
    request: ListUserConversationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ListUserConversationsResponse
    ) => void
  ): ClientUnaryCall;
  pinConversation(
    request: PinConversationRequest,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  pinConversation(
    request: PinConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  pinConversation(
    request: PinConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unPinConversation(
    request: UnPinConversationRequest,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unPinConversation(
    request: UnPinConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unPinConversation(
    request: UnPinConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  archiveConversation(
    request: ArchiveConversationRequest,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  archiveConversation(
    request: ArchiveConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  archiveConversation(
    request: ArchiveConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unArchiveConversation(
    request: UnArchiveConversationRequest,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unArchiveConversation(
    request: UnArchiveConversationRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  unArchiveConversation(
    request: UnArchiveConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse
    ) => void
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse
    ) => void
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: SendMessageResponse
    ) => void
  ): ClientUnaryCall;
  /** Fetch paginated messages for a conversation (chat history). */
  getMessages(
    request: GetMessagesRequest,
    callback: (
      error: ServiceError | null,
      response: GetMessagesResponse
    ) => void
  ): ClientUnaryCall;
  getMessages(
    request: GetMessagesRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetMessagesResponse
    ) => void
  ): ClientUnaryCall;
  getMessages(
    request: GetMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetMessagesResponse
    ) => void
  ): ClientUnaryCall;
  editMessage(
    request: EditMessageRequest,
    callback: (
      error: ServiceError | null,
      response: EditMessageResponse
    ) => void
  ): ClientUnaryCall;
  editMessage(
    request: EditMessageRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: EditMessageResponse
    ) => void
  ): ClientUnaryCall;
  editMessage(
    request: EditMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: EditMessageResponse
    ) => void
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void
  ): ClientUnaryCall;
  addReaction(
    request: AddReactionRequest,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  addReaction(
    request: AddReactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  addReaction(
    request: AddReactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  removeReaction(
    request: RemoveReactionRequest,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  removeReaction(
    request: RemoveReactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  removeReaction(
    request: RemoveReactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MessageResponse) => void
  ): ClientUnaryCall;
  /** Update seen state when user actually reads the message. */
  markMessagesRead(
    request: MarkMessagesReadRequest,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  markMessagesRead(
    request: MarkMessagesReadRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
  markMessagesRead(
    request: MarkMessagesReadRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ConversationResponse
    ) => void
  ): ClientUnaryCall;
}

export const ChatServiceClient = makeGenericClientConstructor(
  ChatServiceService,
  'chat_service.ChatService'
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>
  ): ChatServiceClient;
  service: typeof ChatServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
